- stage_index = 4
- section_index = 0
- lesson_index = 0
- challenge_index = 0

#flappy_square_stage4.page
  %h1 Stage 4

  .description.row.py-3
    .col-xs-6
      %h2.py-2
        Stage 4 Overview
      %p
        In Stage 4 we'll work on our walls a bit more.
      %p
        We need to make sure that if our flappy square runs into them
        then we end the game.
      %p
        It would also be good to randomize how often they appear and how
        big the hole is that the flappy square needs to fly through.

    .col-xs-6
      = image_tag("lessons/flappy_square/stage#{stage_index}/overview.gif", class: 'img-fluid canvas-example')


  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Collision Detection
          %p
            Collision detection is very common in games. You don't want your
            characters running through walls like our flappy square currently is.
          %p
            In order to detect the collision with something else in the game you
            need to compare the position and size of everything in the game to make
            sure nothing overlaps. Unfortunately it takes quite a few calculations to
            check every object (and you have to check each side of the object)
            against every other object. Luckily the computer is very good at making these
            calculations so we can easily make these calculation each frame without slowing
            the animation down.
          %p
            In this example we'll show a simple collision against a wall. Since we
            are only moving right we only need to check to see if the right side of the
            square overlaps with the left edge of the wall at all.
          %p
            This requires a simple check:
          %pre
            %code
              :preserve
                if (box.x + box.size >= wallPosition) {
                  ... end the animation ...
                }
          %p
            This is checking to see if the right side of the box (box.x + box.size)
            has move passed the left side of the wall (its "x" coordinate). If
            it has then we know a collision has taking place.

          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]


        .col-xs-12
          .interactive.focus-on-run.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var time = 0;
                var box = {
                  size: 20,
                  x: 50,
                  y: 100,
                  speed: 3
                };

                var wallPosition = 300;

                function moveBox() {
                  box.x += box.speed;
                }

                function drawBox() {
                  context.fillRect(box.x, box.y, box.size, box.size);
                }

                function drawWall() {
                  context.fillRect(
                    wallPosition,
                    0,
                    canvas.width - wallPosition,
                    canvas.height
                  );
                }

                function checkWallCollision() {
                  if (box.x + box.size >= wallPosition) {
                    clearInterval(interval);

                    context.fillStyle = 'red';
                    drawBox();
                    drawWall();

                    context.font = "30px serif";
                    context.textAlign = 'left';
                    context.textBaseline = 'middle';
                    context.fillText('BANG!', 100, canvas.height / 2);
                  }
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  moveBox();
                  drawBox();
                  drawWall();
                  checkWallCollision();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 50);
                }


                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start the animation.', canvas.width / 2, 50);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();




            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Collision Detection (More Complex)
          %p
            Collision detection is often far more complex than in the lesson above.
            Luckily our flappy square game doesn't require overly complex collision
            detection because our flappy square is always moving right and is always
            in the same "x" position.

          %p
            In this example we'll demonstrate a much more complex situation.
            Instead of one box running into a wall, we'll have many boxes moving
            in random directions and at random speeds bouncing off of each other.
            In order to do this we have to compare every box to every other
            box (as well as the borders of the game) to ensure nothing overlaps and
            then run calculations to determine which direction the collision came from.

          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]


        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var count = 15;
                var size = 20;
                var boxes = [];
                var boundary = {
                  minX: 25,
                  minY: 25,
                  maxX: 450,
                  maxY: 300
                };

                function overlaps(x, y, size, buffer) {
                  if (!buffer) buffer = 0;
                  var minX = x - buffer;
                  var minY = y - buffer;
                  var maxX = x + size + buffer;
                  var maxY = y + size + buffer;

                  for (var i=0; i< boxes.length; ++i) {
                    var box = boxes[i];
                    if (box.x == x && box.y == y) continue;

                    var minBoxX = box.x - buffer;
                    var minBoxY = box.y - buffer;
                    var maxBoxX = box.x + size + buffer;
                    var maxBoxY = box.y + size + buffer;

                    var left = (minX <= maxBoxX && minX >= minBoxX);
                    var right = (maxX >= minBoxX && maxX <= maxBoxX);
                    var top = (minY <= maxBoxY && minY >= minBoxY);
                    var bottom = (maxY >= minBoxY && maxY <= maxBoxY);

                    if ((left || right) && (top || bottom)) {
                      var leftOverlap = maxBoxX - minX;
                      var rightOverlap = maxX - minBoxX;
                      var topOverlap = maxBoxY - minY;
                      var bottomOverlap = maxY - minBoxY;

                      var overlaps = [
                        (left ? leftOverlap : 9999),
                        (right ? rightOverlap : 9999),
                        (top ? topOverlap : 9999),
                        (bottom ? bottomOverlap : 9999)
                      ];

                      var info = {box: box};
                      switch(Math.min.apply(null, overlaps)) {
                        case leftOverlap:
                          info.direction = 'left';
                          break;
                        case rightOverlap:
                          info.direction = 'right';
                          break;
                        case topOverlap:
                          info.direction = 'top';
                          break;
                        case bottomOverlap:
                          info.direction = 'bottom';
                          break;
                      }
                      return info;
                    }
                  }
                  return false;
                }

                function checkBoundary(x, y, size, buffer) {
                  if (!buffer) buffer = 0;
                  outOfBounds = {};
                  if (x + size + buffer > canvas.width) {
                    outOfBounds.right = true;
                  } else if (x < 0) {
                    outOfBounds.left = true;
                  }

                  if (y + size + buffer > canvas.height) {
                    outOfBounds.bottom = true;
                  } else if (y < 0) {
                    outOfBounds.top = true;
                  }
                  return outOfBounds;
                }

                function random(floor, ceil) {
                  return floor + Math.floor(Math.random() * ((ceil + 1) - floor));
                }

                function generateRandomPosition() {
                  var x;
                  var y;
                  do {
                    x = random(boundary.minX, boundary.maxX);
                    y = random(boundary.minY, boundary.maxY);
                  } while (overlaps(x, y, size, size));
                  return {x: x, y: y};
                }

                function generateBoxes() {
                  for (var i=0; i< count; ++i) {
                    var position = generateRandomPosition();

                    boxes.push({
                      x: position.x,
                      y: position.y,
                      xVelocity: [random(2, 6), random(-2, -6)][random(0, 1)],
                      yVelocity: [random(2, 6), random(-2, -6)][random(0, 1)],
                      collidedWith: {}
                    });
                  }
                }

                function adjustPositions() {
                  for (var i=0; i< count; ++i) {
                    boxes[i].x += boxes[i].xVelocity;
                    boxes[i].y += boxes[i].yVelocity;

                    var collision = overlaps(boxes[i].x, boxes[i].y, size);
                    if (collision) {
                      if (collision.box.collidedWith[i] > 0) {
                        collision.box.collidedWith[i] -= 1;
                      } else {
                        collision.box.collidedWith[i] = 5;

                        var newVelocity;
                        switch(collision.direction) {
                          case 'left':
                          case 'right':
                            newVelocity = collision.box.xVelocity;
                            collision.box.xVelocity = boxes[i].xVelocity;
                            boxes[i].xVelocity = newVelocity;
                            break;
                          case 'top':
                          case 'bottom':
                            newVelocity = collision.box.yVelocity;
                            collision.box.yVelocity = boxes[i].yVelocity;
                            boxes[i].yVelocity = newVelocity;
                            break;
                        }
                      }
                    } else {
                      boxes[i].collidedWith = {};
                    }

                    var boundary = checkBoundary(boxes[i].x, boxes[i].y, size);
                    if (Object.keys(boundary).length > 0) {
                      if (boundary.left || boundary.right) {
                        if (boundary.left) boxes[i].x = 1;
                        if (boundary.right) boxes[i].x = canvas.width - size - 1;
                        boxes[i].xVelocity = boxes[i].xVelocity * -1;
                      }

                      if (boundary.top || boundary.bottom) {
                        if (boundary.top) boxes[i].y = 1;
                        if (boundary.bottom) boxes[i].y = canvas.height - size - 1;
                        boxes[i].yVelocity = boxes[i].yVelocity * -1;
                      }
                    }
                  }
                }

                function drawBoxes() {
                  for (var i=0; i< count; ++i) {
                    var box = boxes[i];
                    context.save();
                    context.translate(box.x, box.y);
                    context.fillRect(0, 0, size, size);
                    context.fillStyle = 'white';
                    context.font = "10px serif";
                    context.textAlign = 'center';
                    context.textBaseline="middle";
                    context.fillText(i + 1, size/2, size/2);
                    context.restore();
                  }
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);

                  adjustPositions();
                  drawBoxes();
                }

                function runProgram() {
                  generateBoxes();
                  interval = setInterval(programSteps, 50);
                }


                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start the animation.', canvas.width / 2, 50);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();



            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}


  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            So now we're going to take our code from Stage
            = stage_index - 1
            and we're going
            to track whether our flappy square runs into a wall.
          %p
            Collision detection is one of the more complicated problems you'll
            deal with when developing a game. The lesson above demonstrates how
            complex the calculations are. So take your time with this challenge
            and don't get discouraged. It's hard stuff.
          %p
            Luckily because our flappy square is flying constantly to the right
            we don't need to worry about collisions to the left. This simplifies
            things a bit. When the flappy square is in the same "x" coordinates
            as a wiall we need to check to see if the flappy square is passing
            through the hole in the wall.
          %p
            In each frame we'll find the wall that the flappy square is flying
            through (if any) and make sure it is not flying through any of the
            "wall" area.
          %p
            So, for example, if we wanted to check whether flappy square had passed
            beyond the right side of a wall (really the right side of the wall has
            passed the stationary flappy square) we could do something like this:
          %pre
            %code
              :preserve
                var left = square.x;
                var wallRight = wallX + wall.width;
                if (left > wallRight) {
                  ... right side of wall has passed the left side of the flappy square ...
                }
          %p
            We'll also need to keep track of the positions of each wall to find
            the wall the flappy square is flying through.
          %p
            You can do this by recording the "x" coordinate of each wall in a variable:
          %pre
            %code
              :preserve
                var wall = {
                  ...
                  positions: []
                }

                ...

                wall.positions.push(wallX);
          %p
            Then, you can iterate through these positions like so:
          %pre
            %code
              :preserve
                for (var i=0; i < wall.positions.length; ++i) {
                  var position = wall.positions[i];
                }
          %p
            You just need to be careful not to store the same wall multiple
            times. You may want to store values first, only storing the positions
            of new walls, and then draw all of the walls.
          %p
            This is a
            = link_to_lesson('for loop', :for_loops, nil, class: 'reference-link', data: {slug: :for_loops})
            and you can use it to perform an action using each of the positions in
            your
            %code position
            array.

          %p
            In the example code below we find the wall that the flappy square is passing
            through and check to see that the flappy square is above the bottom
            of the top part of the wall (not going through the hole). If it is
            then we call the method, endGame(), that we currently call from
            checkBoundary() to end the game.
          %pre
            %code
              :preserve
                var left = square.x;
                var right = square.x + square.size;
                var top = square.y;
                var bottom = square.y + square.size;

                for (var i=0; i < wall.positions.length; ++i) {
                  var wallLeft = wall.positions[i] - distance;
                  var wallRight = wallLeft + wall.width;

                  if (wallLeft > right) continue;
                  if (wallRight < left) continue;

                  var topWallBottom = boundary.minY + wall.height;
                  if (top < topWallBottom) {
                    endGame();
                  }
                }

          %p
            Remember this is only checking if the flappy square is hitting the
            top portion of the wall. You'll need to ensure it isn't hitting the bottom
            portion as well.

          %p
            It's a bit complicated. Try to imagine each interaction (e.g. the square
            moving to the right and running into a top wall) and figuring out how you would
            know that the right side of the square has connected with the left side of
            the wall while the square is above the bottom of the wall (for the top part
            of the wall).
          %p
            Yea, it's complicated.
          %p
            Take it slowly and try to work it out.
          %p
            In the end your flappy square should behave like the example provided at
            the beginning of this description.
          = render 'lessons/relevant', relevant: [:for_loops]
          - last_stage = stage_index - 1
          - last_challenge = @challenge_path[:stages][stage_index - 2]
          = render 'lessons/code_preview', stage: last_stage, challenge: last_challenge, editor_id: "flappy_square_stage#{last_stage}_challenge#{last_challenge}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              spacing:
              width:
              height:
              positions: []
            };

            function drawSquare() {
            }

            function drawBoundary() {
            }

            function drawWall(x) {
            }

            function drawWalls() {

              // Remember to track their positions
              // in wall.positions as well.

            }

            function flap() {
            }

            function adjustPosition() {
            }

            function clearBoundary() {
            }

            function checkBoundary() {
            }

            function checkWalls() {

              // CODE TO CHECK FOR WALL COLLISIONS HERE

            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {

              // Remember to run checkBoundary()
              // and checkWalls() from there.

            }

            function runProgram() {
              interval =
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              spacing: 125,
              width: 50,
              height: 100,
              positions: []
            };

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawBoundary() {
              context.beginPath();
              context.moveTo(boundary.minX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.maxY);
              context.lineTo(boundary.minX, boundary.maxY);
              context.closePath();
              context.stroke();
            }

            function drawWall(x) {
              context.fillRect(x, boundary.minY, wall.width, wall.height);
              context.fillRect(x, boundary.maxY - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              var wallX = distance - wall.width;

              if (wall.positions.length > 0) {
                wallX = wall.positions[wall.positions.length - 1];
              } else if (wallX < wall.spacing) {
                wallX = wall.spacing;
              }

              while (wallX < canvas.width + distance + wall.width) {
                if (wallX  % wall.spacing === 0) {
                  wall.positions.push(wallX);
                }
                wallX += 1;
              }

              for (var i=0; i < wall.positions.length; ++i) {
                var position = wall.positions[i];
                drawWall(position - distance);
              }
            }

            function flap() {
              square.yVelocity = square.jump;
            }

            function adjustPosition() {
              distance += 2;
              square.yVelocity += gravity;
              square.y += square.yVelocity;
            }

            function clearBoundary() {
              context.clearRect(0, 0, canvas.width, boundary.minY);
              context.clearRect(boundary.maxX, 0, canvas.width - boundary.maxX, canvas.height);
              context.clearRect(0, boundary.maxY, canvas.width, canvas.height - boundary.maxY);
              context.clearRect(0, 0, boundary.minX, canvas.height);
            }

            function checkBoundary() {
              if (square.y >= boundary.maxY) {
                endGame();
              }
            }

            function checkWalls() {
              var left = square.x;
              var right = square.x + square.size;
              var top = square.y;
              var bottom = square.y + square.size;

              for (var i=0; i < wall.positions.length; ++i) {
                var wallLeft = wall.positions[i] - distance;
                var wallRight = wallLeft + wall.width;

                if (wallLeft > right) continue;
                if (wallRight < left) continue;

                var topWallBottom = boundary.minY + wall.height;
                var bottomWallTop = boundary.maxY - wall.height;
                if (top < topWallBottom || bottom > bottomWallTop) {
                  endGame();
                }
              }
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {
              context.clearRect(0, 0, canvas.width, canvas.height);
              adjustPosition();
              drawSquare();
              drawBoundary();
              drawWalls();
              clearBoundary();
              checkWalls();
              checkBoundary();
            }

            function runProgram() {
              interval = setInterval(programSteps, 80);
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();




  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Randomization
          %p
            Our game isn't very interesting with every wall looking the exact same.
          %p
            Randomizing the spacing between the walls, and the location and size of
            the hole in the wall would make the game more interesting and challenging.
          %p
            In this lesson we look at creating a drawing using random numbers.
          %p
            We'll create a simple cityscape using rectangles that are different widths
            and heights drawn next to each other.
          %p
            The
            %code Math.random()
            method allows us to randomize this process so if you hit "Run" multiple
            times you'll see the randomly generated "buildings" change each time.
          %p
            So if we wanted to generate a random number between 40 and 200 for our
            building height we can do something like this:
          %pre
            %code
              :preserve
                40 + Math.floor(Math.random() * 160)

          %p
            The
            %code Math.random()
            generates a random decimal between 0 and 1 (such as 0.8). We multiply
            that decimal by the maximum number we want (in this case 160 or 200 - 40)
            to get a number between 0 and that maximum number.
          %p
            %code Math.floor()
            then rounds that number down (for example from 129.83 to just 129) and we
            add 40 to give us a random integer between 40 and 200.

          = render 'lessons/relevant', relevant: [:random, :round, :coordinates, :fill_rect]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var ground = canvas.height - 20;
                function drawBuilding(x, width, height) {
                  context.fillRect(x, ground - height, width, height);
                }

                function random(lowerBound, upperBound) {
                  return lowerBound + Math.floor(
                    Math.random() * (upperBound - lowerBound)
                  );
                }

                var totalX = 0;
                while(totalX < canvas.width) {
                  var width = random(40, 100);
                  var height = random(50, 250);
                  drawBuilding(totalX, width, height);
                  totalX += width + 2;
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Our game landscape is a little repetitive. Each wall is equally spaced apart
            and the holes through the walls are all the same size and in the same position.
            We need to mix it up a bit more.
          %p
            Let's take our code from challenge 1 and randomize both the spacing of the walls
            and the size and position of the holes.
          %p
            Use the
            %code Math.random()
            method to produce a random decimal between 0 and 1.
            Then multiply that decimal by a larger number to create a random number
            between 0 and that number. Use
            %code Math.floor()
            to produce an integer. Then you can add to that randomly produced integer
            to change the range (for example add 40 to go from 0 - 160 to 40 - 200).
          %p
            This looks something like this:
          %pre
            %code
              :preserve
                40 + Math.floor(Math.random() * 160)
          %p
            If you run this multiple times you'll get values ranging between 40 and 200.
          %p
            Use something similar to
            %span.highlight position walls between 100 and 200 pixels apart.
          %p
            You also need to keep track of where you position the walls so that they don't
            move around randomly as you draw each frame. Make sure that your wall collision
            detection works properly with their new random positions.
          %p
            This is harder than it sounds when you're dealing with a moving background.
            You'll need to position enough walls so that as the background moves the walls
            keep coming, indefinitely.
          %p
            There are many ways to do this, but I'd suggest you position walls until at least
            one wall is outside the bounds of the canvas. Once that wall is within the bounds
            of the canvas then you position the next wall off the canvas. If you continue doing
            this then you'll always have one wall outside of the bounds of the game ready to
            come in to view.
          %p
            Let's also widen the hole in each wall so that we can easily fly through them
            and observe the random spacing between our walls more easily. Make
            the
            %span.highlight height of the walls 75 instead of 100.

          %p
            In the end your flappy square should behave like the example provided at
            the beginning of this description.
          = render 'lessons/relevant', relevant: [:random, :round, :coordinates, :fill_rect]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              width:
              height:
              positions: []
            };

            function drawSquare() {
            }

            function drawBoundary() {
            }

            function drawWall(x) {
            }

            function drawWalls() {

              // Use Math.random() to position
              // the walls randomly. Remember to
              // track the position of each wall.

            }

            function flap() {
            }

            function adjustPosition() {
            }

            function clearBoundary() {
            }

            function checkBoundary() {
            }

            function checkWalls() {
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {
            }

            function runProgram() {
              interval =
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              width: 50,
              height: 75,
              positions: []
            };

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawBoundary() {
              context.beginPath();
              context.moveTo(boundary.minX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.maxY);
              context.lineTo(boundary.minX, boundary.maxY);
              context.closePath();
              context.stroke();
            }

            function drawWall(x) {
              context.fillRect(x, boundary.minY, wall.width, wall.height);
              context.fillRect(x, boundary.maxY - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              var wallX;
              if (wall.positions.length > 0) {
                wallX = wall.positions[wall.positions.length - 1];
              } else {
                wallX = boundary.minX + 125;
                wall.positions.push(wallX);
              }

              while (wallX < canvas.width + distance + wall.width) {
                wallX += (100 + Math.floor(Math.random() * 100));
                wall.positions.push(wallX);
              }

              for (var i=0; i < wall.positions.length; ++i) {
                var position = wall.positions[i];
                drawWall(position - distance);
              }
            }

            function flap() {
              square.yVelocity = square.jump;
            }

            function adjustPosition() {
              distance += 2;
              square.yVelocity += gravity;
              square.y += square.yVelocity;
            }

            function clearBoundary() {
              context.clearRect(0, 0, canvas.width, boundary.minY);
              context.clearRect(boundary.maxX, 0, canvas.width - boundary.maxX, canvas.height);
              context.clearRect(0, boundary.maxY, canvas.width, canvas.height - boundary.maxY);
              context.clearRect(0, 0, boundary.minX, canvas.height);
            }

            function checkBoundary() {
              if (square.y >= boundary.maxY) {
                endGame();
              }
            }

            function checkWalls() {
              var left = square.x;
              var right = square.x + square.size;
              var top = square.y;
              var bottom = square.y + square.size;

              for (var i=0; i < wall.positions.length; ++i) {
                var wallLeft = wall.positions[i] - distance;
                var wallRight = wallLeft + wall.width;

                if (wallLeft > right) continue;
                if (wallRight < left) continue;

                var topWallBottom = boundary.minY + wall.height;
                var bottomWallTop = boundary.maxY - wall.height;
                if (top < topWallBottom || bottom > bottomWallTop) {
                  endGame();
                }
              }
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {
              context.clearRect(0, 0, canvas.width, canvas.height);
              adjustPosition();
              drawSquare();
              drawBoundary();
              drawWalls();
              clearBoundary();
              checkWalls();
              checkBoundary();
            }

            function runProgram() {
              interval = setInterval(programSteps, 80);
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();








  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"
          %p
            Ok, now that we have a better understanding of randomization let's apply it to the
            position and size of the hole in each wall.
          %p
            Rather than having each portion of the wall be the same height (75 pixels) let's
            vary them by randomizing the height of the top and bottom portion of the wall,
            creating varying hole positions and sizes.
          %p
            You can play around with varying sizes, but I'd suggest varying the top portion
            %span.highlight between 25 and 150 pixels.
            Then you'll want to create a varying height for the bottom portion that
            is within the same parameters but you need to be careful. If you
            randomly create two walls that are 150 pixels then you won't have any room
            for the hole and you probably want the hole to be at least
            %span.highlight 75 pixels.
            Similarly if you both the top and bottom portions of the wall are 25 pixels then
            your hole will be 225 pixels (300 - 25 - 50), which is very big. So you may
            want to make your hole no more than 150 pixels as well...

          %p
            You'll need to store this information as well so that you can draw the same hole
            in each frame. You may want to store a hash in the "positions" attribute of your "walls"
            variable that contains the position, the height of the top wall, and the size of the
            hole.
          %p
            You'll need to update your wall collision detection to take this information into
            account as well.
          %p
            In the end your flappy square should behave like the example to the right.
          = render 'lessons/relevant', relevant: [:random, :coordinates, :fill_rect]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              width:
              height:
              positions: []
            };

            function drawSquare() {
            }

            function drawBoundary() {
            }

            function drawWall(wallInfo) {

              // You'll need to pass in all of the
              // wall information and use it to
              // draw a wall with the specified
              // top and bottom heights.

              // You may also want to account for
              // distance here now as well.

            }

            function drawWalls() {

              // Set the height of the top and
              // bottom portions of the wall
              // randomly and track them.

            }

            function flap() {
            }

            function adjustPosition() {
            }

            function clearBoundary() {
            }

            function checkBoundary() {
            }

            function checkWalls() {

              // Be sure to incorporate
              // the new randomly generated
              // heights.

            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {
            }

            function runProgram() {
              interval =
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var distance = 0;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              maxX: 450,
              maxY: 300
            };

            var square = {
              x: 50,
              y: 100,
              size: 20,
              yVelocity: 0,
              jump: -8
            };

            var wall = {
              width: 50,
              minHole: 75,
              maxHole: 150,
              positions: []
            };

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawBoundary() {
              context.beginPath();
              context.moveTo(boundary.minX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.minY);
              context.lineTo(boundary.maxX, boundary.maxY);
              context.lineTo(boundary.minX, boundary.maxY);
              context.closePath();
              context.stroke();
            }

            function drawWall(wallInfo) {
              var x = wallInfo.x - distance;
              context.fillRect(
                x,
                boundary.minY,
                wall.width,
                wallInfo.topHeight
              );
              context.fillRect(
                x,
                boundary.maxY - wallInfo.bottomHeight,
                wall.width,
                wallInfo.bottomHeight
              );
            }

            function random(min, max) {
              return (min + Math.floor(Math.random() * (max - min)));
            }

            function drawWalls() {
              var wallX = square.x;
              if (wall.positions.length > 0) {
                wallX = wall.positions[wall.positions.length - 1].x;
              }

              var end = boundary.maxX + distance + wall.width;
              var boundaryHeight = boundary.maxY - boundary.minY;

              while (wallX < end) {
                wallX += random(100, 200);

                var topHeight = random(25, 150);
                var bottomHeight = random(25, 150);
                if (boundaryHeight - topHeight - bottomHeight < wall.minHole) {
                  bottomHeight = boundaryHeight - topHeight - wall.minHole;
                }
                if (boundaryHeight - topHeight - bottomHeight > wall.maxHole) {
                  bottomHeight = boundaryHeight - topHeight - wall.maxHole;
                }

                wall.positions.push({
                  x: wallX,
                  topHeight: topHeight,
                  bottomHeight: bottomHeight
                });
              }

              for (var i=0; i < wall.positions.length; ++i) {
                drawWall(wall.positions[i]);
              }
            }

            function flap() {
              square.yVelocity = square.jump;
            }

            function adjustPosition() {
              distance += 2;
              square.yVelocity += gravity;
              square.y += square.yVelocity;
            }

            function clearBoundary() {
              context.clearRect(0, 0, canvas.width, boundary.minY);
              context.clearRect(boundary.maxX, 0, canvas.width - boundary.maxX, canvas.height);
              context.clearRect(0, boundary.maxY, canvas.width, canvas.height - boundary.maxY);
              context.clearRect(0, 0, boundary.minX, canvas.height);
            }

            function checkBoundary() {
              if (square.y >= boundary.maxY) {
                endGame();
              }
            }

            function checkWalls() {
              var left = square.x;
              var right = square.x + square.size;
              var top = square.y;
              var bottom = square.y + square.size;

              for (var i=0; i < wall.positions.length; ++i) {
                var wallInfo = wall.positions[i];
                var wallLeft = wallInfo.x - distance;
                var wallRight = wallLeft + wall.width;

                if (wallLeft > right) continue;
                if (wallRight < left) continue;

                var topWallBottom = boundary.minY + wallInfo.topHeight;
                var bottomWallTop = boundary.maxY - wallInfo.bottomHeight;
                if (top < topWallBottom || bottom > bottomWallTop) {
                  endGame();
                }
              }
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {
              context.clearRect(0, 0, canvas.width, canvas.height);
              adjustPosition();
              drawSquare();
              drawBoundary();
              drawWalls();
              clearBoundary();
              checkWalls();
              checkBoundary();
            }

            function runProgram() {
              interval = setInterval(programSteps, 80);
            }

            canvas.addEventListener('click', flap);



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();
