- lesson_index = 0
- challenge_index = 0

#flappy_square_stage2.page
  %h1 Stage 2

  .description.row.py-3
    .col-xs-6
      %h2.py-2
        Stage 2 Overview
      %p
        In this stage we'll make our flappy bird fly!
        We'll listen for a click on the canvas and
        make our flappy bird fly a bit before falling
        back down.
      %p
        Then, if the bird falls outside of the game area
        we'll end the game.
      %p
        Lastly we'll create a simple moving background that
        the flappy square can fly through. We won't yet check
        to see if the flappy square runs into any walls, we'll
        just create them to provide the illusion of movement.

    .col-xs-6
      = image_tag('lessons/flappy_square/stage2/overview.gif', class: 'img-fluid canvas-example')


  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Responding To Events
          %p
            In Stage 1 we caught a glimpse of
            = link_to_lesson('event listeners', :event_listeners, nil, class: 'reference-link', data: {slug: :event_listeners})
            in the code we provided you that starts and pauses the animations when the
            canvas receives or loses focus (the 'focus' and 'blur' events).
          %p
            In this example we'll and an event listener that listens for mouse clicks
            and we'll move our square to where ever we click.
          %p
            We can listen for clicks on the canvas using code like this:
          %pre
            %code
              :preserve
                canvas.addEventListener('click', handleClick);
          %p
            Click around on the canvas and watch how the square jumps to each mouse click.

          = render 'lessons/relevant', relevant: [:event_listeners, :fill_rect, :coordinates]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                function drawSquare(x, y) {
                  context.fillRect(x - 20, y - 20, 40, 40);
                }

                function reset() {
                  context.clearRect(0, 0, canvas.width, canvas.height);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to move the square.', canvas.width / 2, 50);
                }

                function handleClick(e) {
                  reset();
                  drawSquare(e.layerX, e.layerY);
                }

                canvas.addEventListener('click', handleClick);
                reset();
                drawSquare(100, 100);


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Take your code from Stage 1 and make your flappy square fly.
          %p
            Listen for
            %span.highlight a click event
            on the canvas. When a click is received set the
            %span.highlight "yVelocity" to the "jump" variable.
            And let's set the
            %span.highlight "jump" variable to 8.
            This will cause the flappy square to jump up before
            being pulled back down by gravity.
          %p
            We'll also slow down the framerate so that you have more time to
            click on the canvas before the square falls off the canvas. For now
            let's set it to draw one frame every
            %span.highlight 80 miliseconds
            (this will be slow, but it will be a better framerate for testing).

          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:event_listeners]
          = render 'lessons/code_preview', stage: 1, challenge: 7, editor_id: 'flappy_square_stage1_challenge7_editor'

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage1_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = ;
            var size = 20;
            var x = ;
            var y = ;
            var jump = ;
            var yVelocity = ;

            function drawSquare() {
            }

            function flap() {

              // CODE FOR ONE "FLAP"

            }

            function adjustPosition() {
            }

            function programSteps() {
            }

            function runProgram() {
              interval =
            }

            // CODE TO CALL flap METHOD WHEN CANVAS IS CLICKED



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            pauseAnimation();

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert


  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: A Game Area
          %p
            We're going to want to create a "game area" which
            is essentially just a square drawn within the canvas
            that represents the valid area for the game to be drawn in.
          %p
            It also will allow us to display the game name and score
            above the game area later in Stage 4.
          %p
            In this example we demonstrate a drawn area that, when you
            move your mouse over if will say "In Game" and when you move
            out of it will say "Out Of Game".
          %p
            In order to draw the game area we'll need to use the
            = link_to_lesson('context.lineTo()', :line_to, nil, class: 'reference-link', data: {slug: :line_to})
            method. It's a bit more compicated than the
            %code context.fillRect()
            method, though. When drawing a line you first trace the
            path using
            %code context.beginPath()
            %code context.moveTo()
            and
            %code context.lineTo()
            and then you paint the path using
            %code context.stroke()
          %p
            Look at this example to see how
            %code context.beginPath()
            %code context.moveTo()
            %code context.lineTo()
            and
            %code context.stroke()
            are used to draw the square. You can also click on the
            "lineTo()" button below in the "Relevant Lessons" section to see more details.
          = render 'lessons/relevant', relevant: [:line_to, :event_listeners]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var boundary = {
                  minX: 50,
                  maxX: 400,
                  minY: 50,
                  maxY: 400
                };

                function drawBoundary() {
                  context.lineWidth = 2;
                  context.beginPath();
                  context.moveTo(boundary.minX, boundary.minY);
                  context.lineTo(boundary.minX, boundary.maxY);
                  context.lineTo(boundary.maxX, boundary.maxY);
                  context.lineTo(boundary.maxX, boundary.minY);
                  context.closePath();
                  context.stroke();
                }

                function handleMouseMove(e) {
                  context.clearRect(0, 0, canvas.width, canvas.height);

                  drawBoundary();

                  var x = e.layerX;
                  var y = e.layerY;
                  var inOut;
                  if (x > boundary.minX && x < boundary.maxX && y > boundary.minY && y < boundary.maxY) {
                   inOut = 'inside the game area.';
                  } else {
                   inOut = 'outside the game area.';
                  }
                  context.fillText('Your mouse is: ' + inOut, boundary.minX, 40);
                }

                canvas.addEventListener('mousemove', handleMouseMove);

                context.font = "20px serif";
                context.fillText('Mouse over the canvas.', boundary.minX, 40);
                drawBoundary();

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's take the code from Challenge
            = challenge_index - 1
            and add a boundary for our game.
          %p
            The boundary should
            %span.highlight start at (25, 25) and extend to (450, 400),
            forming a rectangle. Use
            %code context.lineTo()
            to draw the boundary. Be sure to use
            %code context.beginPath()
            %code context.moveTo()
            and
            %code context.stroke()
            as described in the lesson above.
          %p
            We'll also start organizing our variables into hashes which allow us to
            organize variables more effectively. Here's an example:
          %pre
            %code
              :preserve
                var rectangle = {
                  height: 10,
                  width: 20
                }

                rectangle.width
                => 20
          %p
            For our purposes we'll introduce
            %span.highlight hashes for the "square" and the "boundary"
            and store all of the relevant variables in those hashes.

          %p In the end your flappy square should behave like the example provided to the right.
          = render 'lessons/relevant', relevant: [:line_to, :event_listeners]
          = render 'lessons/code_preview', stage: 2, challenge: challenge_index - 1, editor_id: "flappy_square_stage2_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage2_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;

            // FILL IN YOUR VARIABLES USING THIS HASH FORMAT HERE.
            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            function drawBoundary() {

              // Draw your boundary using boundary.minX, boundary.minY, etc. here.

            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
            }

            function programSteps() {

              // Don't forget to draw your boundary!

            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            pauseAnimation();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert


  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Monitoring Game State
          %p
            In any game your code will need to be constantly monitoring
            the environment, calculating whether different objects
            are colliding or staying in bounds, etc.
          %p
            In our game one thing we need to monitor for is whether the
            flappy square falls off the screen.
          %p
            In this example we demonstrate a ball moving toward a line.
            In each frame we call a function:
          %pre
            %code
              :preserve
                function checkBoundary() {
                  if (ball.x + ball.radius >= wall.x) {
                    endAnimation();
                  }
                }
          %p
            This code will constantly check to see if the ball has crossed
            the line and will end the animation if it does.

          = render 'lessons/relevant', relevant: [:line_to]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var ball = {
                  radius: 10,
                  x: 50,
                  y: 150
                };

                var line = {
                  x: 250
                };

                function drawLine() {
                  context.beginPath();
                  context.moveTo(line.x, 0);
                  context.lineTo(line.x, canvas.height);
                  context.stroke();
                }

                function drawBall() {
                  context.save()
                  context.beginPath()
                  context.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI, false)
                  context.closePath()
                  context.fill()
                  context.restore()
                }

                function adjustPosition() {
                  ball.x += 1;
                }

                function checkBoundary() {
                  if (ball.x + ball.radius >= line.x) {
                    endAnimation();
                  }
                }

                function endAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Boundary Reached.', canvas.width / 2, 100);
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  adjustPosition();
                  drawLine();
                  drawBall();
                  checkBoundary();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 25);
                }

                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start the animation.', canvas.width / 2, 50);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's take the code from Challenge
            = challenge_index - 1
            and check to make sure our flappy square hasn't fallen below the boundary.

          %p
            When the flappy square goes above the maximum y value for the boundary
            (remember y values are larger at the bottom of the canvas) we'll
            stop the game and display a message.

          %p
            We've provided the code to stop the game and display the message. You need
            to call the method and determine when the game should be ended in your
            %code checkBoundary()
            function.

          %p In the end your flappy square should behave like the example provided to the right.
          = render 'lessons/relevant', relevant: [:line_to, :event_listeners]
          = render 'lessons/code_preview', stage: 2, challenge: challenge_index - 1, editor_id: "flappy_square_stage2_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage2_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;

            // FILL IN YOUR VARIABLES USING THIS HASH FORMAT HERE.
            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            function drawBoundary() {
            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
            }

            function checkBoundary() {

              // CODE TO CHECK WHETHER FLAPPY SQUARE
              // IS ABOVE BOUNDARY FLOOR HERE.
              if () {
                endGame();
              }

            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {

              // Don't forget to check your boundary!

            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            pauseAnimation();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert


  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: An Algorithmic Background
          %p
            Our game needs a background. This background will eventually
            be a series of walls with holes in them that are randomly generated
            by the code. These walls will continuously move toward the flappy square.
          %p
            Since there are essentially an unlimited number of walls we'll need to
            create them algorithmically. This means that rather than explicitly
            writing code that draws these walls, which would take forever,
            we need to write code that itself determines where the walls should go.
          %p
            In this example we show a series of trees. We could call our drawTree()
            method explicitly like this:
          %pre
            %code
              :preserve
                var treeY = canvas.height - road.height;
                drawTree(50, treeY);
                drawTree(80, treeY);
                drawTree(110, treeY);
                drawTree(140, treeY);
                ... etc, etc ...
          %p
            Or we could draw trees algorithmically, drawing them every 75 pixels until
            the end of the canvas is reached. This would look like:
          %pre
            %code
              :preserve
                var treeSpacing = 75;
                var treeX = 0;
                var treeY = canvas.height - road.height;
                while (treeX < canvas.width) {
                  drawTree(treeX, treeY);
                  treeX += treeSpacing;
                }
          %p
            This code starts at
            %code treeX = 0
            and loops over and over, drawing one tree each time while also
            adding 75 (treeSpacing) to treeX while treeX is less than the width of the
            canvas plus treeSpacing (to account for trees on the border).
          %p
            Check out the lesson on
            = link_to_lesson('while loops', :while_loops, nil, class: 'reference-link', data: {slug: :while_loops})
            to better understand how these loops work.
          %p
            The example below uses this code to draw our algorithmic background, drawing
            a tree every 75 pixels.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates, :while_loops]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var road = {
                  height: 30
                };

                function drawRoad() {
                  context.save();
                  context.fillStyle = '#cccccc';
                  var roadY = canvas.height - road.height;
                  context.fillRect(0, roadY, canvas.width, road.height);
                  context.restore();
                }

                function drawGrass() {
                  context.save();
                  context.fillStyle = '#238d23';
                  var grassHeight = 6;
                  var grassY = canvas.height - road.height - grassHeight;
                  context.fillRect(0, grassY, canvas.width, grassHeight);
                  context.restore();
                }

                function drawTrees() {
                  var treeSpacing = 75;
                  var treeX = 0;
                  var treeY = canvas.height - road.height;
                  while (treeX < canvas.width + treeSpacing) {
                    drawTree(treeX, treeY);
                    treeX += treeSpacing;
                  }
                }

                function drawTree(centerX, bottomY) {
                  context.save();
                  context.translate(centerX, bottomY);
                  context.fillStyle = '#a5681c';
                  context.fillRect(0, -60, 12, 60);

                  context.beginPath();
                  context.arc(6, -60, 32, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = '#238d23';
                  context.fill();

                  context.restore();
                }

                drawRoad();
                drawGrass();
                drawTrees();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's add a background to our game. We need to begin the process
            of creating the walls our flappy square needs to navigate.
          %p
            Eventually we'll need to animate this background, randomize it,
            and track to make sure that we are not running into the walls.
          %p
            Let's start, though, by simply adding a series of rectangles to the roof
            of the game area with matching rectangles on the floor of the game area.
          %p
            So try to draw two rectangles (a wall), one attached to the
            %span.highlight roof (y = 50)
            and one to the
            %span.highlight floor (y = 400)
            Each of them should be
            %span.highlight 100 pixels tall and 50 pixels wide.
            and each wall should be space
            %span.highlight 125 pixels apart.
          %p 
            We also don't want to draw our walls right on top of the flappy square
            when the game starts, so let's draw the first one 125 pixels out.
          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates]
          = render 'lessons/code_preview', stage: 2, challenge: challenge_index - 1, editor_id: "flappy_square_stage2_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage2_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;

            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            var walls = {
              height: ,
              width: ,
              spacing:
            };

            function drawBoundary() {
            }

            function drawWalls() {

              // Draw your walls here.

            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
            }

            function checkBoundary() {
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {

              // Don't forget to draw the walls!

            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            pauseAnimation();


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert


  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: A Moving Background
          %p
            In our game our flappy square will fly through a series of
            random holes. These holes will move toward the flappy square,
            giving the impression that the flappy square is flying through
            them even though it is staying in the same spot on the canvas.
          %p
            In this example we'll demonstrate a background that moves to the
            left while a red ball stays stationary, giving the impression
            that the ball is rolling through the background.
          %p
            We'll use a variable, distance, to track the position of the background,
            adjusting the position of each tree drawn by 'distance'. Each frame
            adjusts 'distance' by 2 pixels, causing each tree to be drawn 2 pixels
            to the left.
          %p
            Then we can draw a tree every time distance is divisible by treeSpacing:
          %pre
            %code
              :preserve
                if (distance % treeSpacing == 0) {
                  var treeY = canvas.height - roadHeight;
                  drawTree(i - distance, treeY);
                }
          %p
            When this is done fast enough it creates the illusion of the trees
            moving slowly, which in turn creates the illusion of the ball moving
            because in real life backgrounds don't move.


          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var roadHeight = 40;
                var distance = 0;
                var treeSpacing = 100;

                function drawRoad() {
                  context.save();
                  context.fillStyle = '#cccccc';
                  var roadY = canvas.height - roadHeight;
                  context.fillRect(0, roadY, canvas.width, roadHeight);
                  context.restore();
                }

                function drawGrass() {
                  context.save();
                  context.fillStyle = '#238d23';
                  var grassHeight = 6;
                  var grassY = canvas.height - roadHeight - grassHeight;
                  context.fillRect(0, grassY, canvas.width, grassHeight);
                  context.restore();
                }

                function drawTrees() {
                  var space = 100;
                  var startX = distance - space;
                  var maxX = canvas.width + distance + space;
                  for (var i=startX; i < maxX; ++i) {
                    if (i % treeSpacing == 0) {
                      var treeY = canvas.height - roadHeight;
                      drawTree(i - distance, treeY);
                    }
                  }
                }

                function drawTree(centerX, bottomY) {
                  context.save();
                  context.translate(centerX, bottomY);
                  context.fillStyle = '#a5681c';
                  context.fillRect(0, -60, 12, 60);

                  context.beginPath();
                  context.arc(6, -60, 32, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = '#238d23';
                  context.fill();

                  context.restore();
                }

                function drawBall() {
                  var ballRadius = 15;
                  context.save();
                  context.translate(50, canvas.height - (roadHeight/2) - ballRadius);
                  context.beginPath();
                  context.arc(0, 0, ballRadius, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = 'red';
                  context.fill();
                  context.restore();
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  distance += 2;
                  drawRoad();
                  drawTrees();
                  drawGrass();
                  drawBall();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 50);
                }

                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start the animation.', canvas.width / 2, 50);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();



            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Ok, now we're going to take our flappy square game and add
            a moving background that the flappy square will eventually
            have to navigate.
          %p
            Let's start by a series of rectangles on the roof of the game
            area with matching rectangles on the floor of the game area.
          %p
            While this may sound easy, it's one of the more complicated parts
            of the game:
          %ul
            %li We'll have to draw a wall at a regular interval.
            %li
              In each frame we'll have to draw each wall a little closer to the left,
              creating the illusion that the flappy square is flying through them,
              while maintaining the distance between them.
            %li
              As they move across the canvas and eventually outside of the game
              area to the left we'll need to position and draw new walls coming
              from the right.
          %p
            There are may ways to approach this algorithm. In the lesson above we
            have a variable
            %code distance
            and we
            %span.highlight add 2 to it
            with each frame. Then we draw a tree any time the variable
            %code distance
            is divisible by
            %code treeSpacing
            \-
            %code walls.spacing
            in this challenge.
          %p
            So try to draw two rectangles (a wall), one attached to the
            %span.highlight roof (y = 50)
            and one to the
            %span.highlight floor (y = 400)
            Each of them should be
            %span.highlight 100 pixels tall and 50 pixels wide.
            and each wall should be space
            %span.highlight 125 pixels apart.

          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates]
          = render 'lessons/code_preview', stage: 2, challenge: challenge_index - 1, editor_id: "flappy_square_stage2_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage2_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;
            var distance = 0;

            // FILL IN YOUR VARIABLES USING THIS HASH FORMAT HERE.
            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            var walls = {
              spacing:
              width:
              height:
            };

            function drawBoundary() {
            }

            function drawWalls() {
            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
              // CODE TO ADJUST DISTANCE HERE
            }

            function checkBoundary() {
            }

            function runProgram() {
            }

            function startAnimation() {
              interval =
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert

  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Clearing The Edges
          %p
            Since we have a boundary to our game area, it doesn't look
            great to have any part of our drawing (walls or the flappy square)
            display outside of the boundary.
          %p
            Clearing areas can allow you to accomplish this goal. It can also
            allow you to create complex animations on a single canvas.
          %p
            In this example we take our ball rolling animation and draw it
            in the middle of the canvase, clearing the areas around it so that
            it stays within the designated boundary.

          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage2_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var roadHeight = 40;
                var distance = 0;
                var boundary = {
                  minX: 100,
                  maxX: 400,
                  minY: 100,
                  maxY: 200
                };

                function drawRoad() {
                  context.save();
                  context.fillStyle = '#cccccc';
                  var roadY = boundary.maxY - roadHeight;
                  context.fillRect(0, roadY, canvas.width, roadHeight);
                  context.restore();
                }

                function drawGrass() {
                  context.save();
                  context.fillStyle = '#238d23';
                  var grassHeight = 6;
                  var grassY = boundary.maxY - roadHeight - grassHeight;
                  context.fillRect(0, grassY, canvas.width, grassHeight);
                  context.restore();
                }

                function drawTrees() {
                  var space = 100;
                  var startX = distance - space;
                  var maxX = canvas.width + distance + space;
                  for (var i=startX; i < maxX; ++i) {
                    if (i % space !== 0) continue;
                    context.save();
                    var treeY = boundary.maxY - roadHeight;
                    context.translate(i - distance, treeY);
                    drawTree();
                    context.restore();
                  }
                }

                function drawTree() {
                  context.save();
                  context.fillStyle = '#a5681c';
                  context.fillRect(0, -60, 12, 60);

                  context.beginPath();
                  context.arc(6, -60, 32, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = '#238d23';
                  context.fill();

                  context.restore();
                }

                function clearBoundary() {
                  context.clearRect(0, 0, boundary.minX, canvas.height);
                  context.clearRect(0, 0, canvas.width, boundary.minY);
                  context.clearRect(0, boundary.maxY, canvas.width, canvas.height - boundary.maxY);
                  context.clearRect(boundary.maxX, 0, canvas.width - boundary.maxX, canvas.height);
                }

                function drawBall() {
                  context.save();
                  context.translate(boundary.minX + 50, boundary.maxY - (roadHeight / 2) - 10);
                  context.beginPath();
                  context.arc(0, 0, 15, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = 'red';
                  context.fill();
                  context.restore();
                }

                function runProgram() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  distance += 2;
                  drawRoad();
                  drawTrees();
                  drawGrass();
                  drawBall();
                  clearBoundary();
                }

                function startAnimation() {
                  interval = setInterval(runProgram, 50);
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click on the canvas to start the animation.', canvas.width / 2, 50);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage2_lesson#{lesson_index}"}


  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage2/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            For this challenge we're going to clean up the edges of our game.
          %p
            Right now the walls appear outside of the boundary and, if the flappy square
            goes above or below the boundary we still show it.
          %p
            So we're going to add a method
            %code clearBoundary()
            that will clear the areas outside of the boundary after each frame is drawn.
          %p
            We're basically drawing our full frame and then erasing everything outside of the
            boundary. We'll use the
            = link_to_lesson('context.clearRect()', :clear_rect, nil, class: 'reference-link', data: {slug: :clear_rect})
            to erase everything outside of the boundary we've drawn.

          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:fill_rect]
          = render 'lessons/code_preview', stage: 2, challenge: challenge_index - 1, editor_id: "flappy_square_stage2_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage2_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage2_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;
            var distance = 0;

            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            var walls = {
              spacing:
              width:
              height:
            };

            function drawBoundary() {
            }

            function drawWalls() {
            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
            }

            function clearBoundary() {
              // CODE HERE TO CLEAR ALL AREAS OUTSIDE OF THE BOUNDARY
            }

            function checkBoundary() {
            }

            function runProgram() {
            }

            function startAnimation() {
              interval =
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage2_challenge#{challenge_index}"}
          .alert
