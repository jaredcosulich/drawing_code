- stage_index = 2
- section_index = 0
- lesson_index = 0
- challenge_index = 0

#flappy_square_stage2.page
  %h1 Stage 2

  .description.row.py-3
    .col-xs-6
      %h2.py-2
        Stage 2 Overview
      %p
        In this stage we'll animate our flappy square!
      %p
        We'll walk through a series of challenges that
        move our flappy square toward an animation that
        simulates gravity, causing it to fall off of our
        canvas.

    .col-xs-6
      = image_tag('lessons/flappy_square/stage2/overview.gif', class: 'img-fluid canvas-example')



  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Using Functions
          %p
            Right now we only have one wall. In our game we're going to
            need an endless stream of walls for our flappy square to fly through.
          %p
            Calling
            %code context.fillRect()
            over and over and over again in our code is not going to work.
          %p
            If there is a chunk of code that you are going to use over and over again,
            putting that code into a function can make your life much easier. Then,
            to run the code, all you have to do is call the function by typing one line.
          %p
            %span.highlight
              In this example, we create a function that will draw a French flag. Because
              we might want to draw a French flag in lots of different places, we make the
              x- and y-coordinates of the flag variables.
            When we call drawFrenchFlag(30, 100), the 30 is assigned to the variable <i>x</i>
            and the 100 is assigned to the variable <i>y</i> inside of the function. Now we can
            easily draw as many French flags as we want!
          %p
            Functions are a core concept in software development. If you feel uncertain about them
            you should click on the "Functions" quick reference button below and click on the
            "Full Lesson" button in the pop-up.

          = render 'lessons/relevant', relevant: [:functions, :fill_rect, :fill_style, :coordinates, :variables]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                function drawFrenchFlag(x, y) {
                  context.fillStyle = '#0055A4';
                  context.fillRect(x, y, 20, 40);

                  context.fillStyle = '#FFFFFF';
                  context.fillRect(x + 20, y, 20, 40);

                  context.fillStyle = '#EF4135';
                  context.fillRect(x + 40, y, 20, 40);
                }

                drawFrenchFlag(30, 100);
                drawFrenchFlag(150, 50);
                drawFrenchFlag(300, 180);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}


  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            %span.highlight
              Let's write three functions that draw our boundary, our flappy square, and our wall.

          %p
            Our boundary will be drawn in the
            %code drawBoundary()
            function which will not need any parameters. All of the information we need
            for this function comes from our boundary hash variable.
          %p
            Our flappy square function will be called
            %code drawSquare()
            and will not require any parameters either. We'll use our square hash variable within
            our function to draw the square like so:
          %pre
            %code
              :preserve
                function drawSquare() {
                  context.fillRect(square.x, square.y, square.size, square.size);
                }
          %p
            Lastly our walls will be drawn in the
            %code drawWall(x)
            function which will accept one parameter, the "x" coordinate of the wall.
          %p
            Once your functions are in place we can call the
            %code drawWall(x)
            function three times from a
            %code drawWalls()
            function, creating walls
            %span.highlight every 125 pixels,
            starting from the left border of the boundary.
          %p
            So if you wrote code like this:
          %pre
            %code
              :preserve
                drawWall(100);
                drawWall(200);
          %p
            Then the value of 100 and then 200 would be stored in the "x" variable
            in the drawWall(x) function. The drawWall(x) function would then use
            that x variable to draw one wall at 100 pixels and another wall at
            200 pixels.
          %p
            Once complete your game should look like the example provided above.
          %p
            Note: Functions are a core concept in software development. If you feel uncertain about them
            you should click on the "Functions" quick reference button below and click on the
            "Full Lesson" button in the pop-up.

          = render 'lessons/relevant', relevant: [:functions, :fill_rect, :coordinates, :variables]

          - last_stage = stage_index - 1
          - last_challenge = @challenge_path[:stages][stage_index - 2]
          = render 'lessons/code_preview', stage: last_stage, challenge: last_challenge, editor_id: "flappy_square_stage#{last_stage}_challenge#{last_challenge}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // BOUNDARY HASH HERE

            // SQUARE HASH HERE

            // WALL HASH HERE


            // GAME BOUNDARY FUNCTION

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              // Write your code to draw a wall here
              // but use the "x" variable that is passed
              // in to draw a wall in different places.
            }

            function drawWalls() {
              // CODE TO CALL WALL FUNCTION THREE TIMES HERE
            }

            drawBoundary();
            drawSquare();
            drawWalls();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 50,
              y: 100,
              size: 20
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(boundary.minX, boundary.minY, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, boundary.minY, wall.width, wall.height);
              context.fillRect(x, boundary.minY + boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(boundary.minX + 125);
              drawWall(boundary.minX + (125 * 2));
              drawWall(boundary.minX + (125 * 3));
            }

            drawBoundary();
            drawSquare();
            drawWalls();



  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Using context.translate(x, y)
          %p
            Between our boundary and our walls we're doing a lot of math to position
            everything correctly.
          %p
            For example the example solution above uses the following code in
            our drawBoundary() function:
          %pre
            %code
              :preserve
                function drawBoundary() {
                  context.strokeRect(boundary.minX, boundary.minY, boundary.width, boundary.height);
                }
          %p
            In drawWall(x) we are have:
          %pre
            %code
              :preserve
                context.fillRect(x, boundary.minY + boundary.height - wall.height, wall.width, wall.height);
          %p
            And in drawWalls() we are have:
          %pre
            %code
              :preserve
                drawWall(boundary.minX + 125);
                drawWall(boundary.minX + (125 * 2));
                drawWall(boundary.minX + (125 * 3));
          %p
            In each of these examples we have to do math to shift the everything we
            are drawing to take into account the boundary.


          .float-xs-right.pl-2.pb-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual.png", class: 'img-fluid canvas-example')

          %p
            The canvas's context has a powerful method,
            = link_to_lesson('context.translate(x, y)', :translate, nil, class: 'reference-link', data: {slug: :translate})
            that allows you to shift the origin of the canvas.
          %p
            This means that the point (0, 0) is no longer the top left corner of the canvas.
          %p
            For example, if you were to call
            %code context.translate(50, 200);
            then from then on if you were to call
            %code context.translate(50, 50, 10, 10);
            it would draw a square at the point (100, 250) instead of (50, 50);
          %p
            This means we can shift our origin point to be at the top left
            corner of our boundary instead of the top left corner of the canvas.
            This will greatly simplify our code.
          %p
            In this example we take the flags drawn in the previous example and use
            = link_to_lesson('context.translate(x, y)', :translate, nil, class: 'reference-link', data: {slug: :translate})
            to shift the origin to the top left corner
            of the flag. From there we can more easily draw the flag without having
            to do any math to position the rectangles.

          = render 'lessons/relevant', relevant: [:translate, :functions, :fill_rect, :coordinates, :variables]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                function drawFrenchFlag(x, y) {
                  context.save(); // Save the drawing state before making any changes
                  context.translate(x, y); // Move the origin of the coordinate system to the top left corner of the flag

                  context.fillStyle = '#0055A4';
                  context.fillRect(0, 0, 20, 40); // The blue rectangle is drawn at (0, 0)

                  context.fillStyle = '#FFFFFF';
                  context.fillRect(20, 0, 20, 40); // The white rectangle is drawn at (20, 0)

                  context.fillStyle = '#EF4135';
                  context.fillRect(40, 0, 20, 40); // The red rectangle is drawn at (40, 0)

                  context.restore(); // Restore the drawing state to the way it was when we saved it
                }

                drawFrenchFlag(30, 100);
                drawFrenchFlag(150, 50);
                drawFrenchFlag(300, 180);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's use
            = link_to_lesson('context.translate(x, y)', :translate, nil, class: 'reference-link', data: {slug: :translate})
            to make our code a bit simpler and easier to read.
          %p
            %span.highlight
              Translate the origin from the top left corner of the canvas (0, 0) to the
              top left corner of the boundary (boundary.minX, boundary.minY).
            From that point on the origin (0, 0) will now be the top left corner of the boundary.
          %p
            This means you'll need to change the rest of your code to take into account
            the new origin. This should make the code much simpler.
          %p
            In particular you'll need to
            %span.highlight adjust the "x" and "y" values
            in your square hash variable:
            %code square.x
          %p
            In the end your flappy square game should look just like it did after the last
            challenge but the code should be simplified.

          = render 'lessons/relevant', relevant: [:translate, :functions, :fill_rect, :coordinates, :variables]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // BOUNDARY HASH HERE

            // SQUARE HASH HERE
            // Don't forget to change the x and y values.

            // WALL HASH HERE


            // GAME BOUNDARY FUNCTION

            // DRAW SQUARE FUNCTION

            // DRAW WALL FUNCTION

            // DRAW WALLS FUNCTION


            // CODE TO TRANSLATE THE ORIGIN

            drawBoundary();
            drawSquare();
            drawWalls();


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 25,
              y: 75,
              size: 20
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(0, 0, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, 0, wall.width, wall.height);
              context.fillRect(x, boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(125);
              drawWall(125 * 2);
              drawWall(125 * 3);
            }

            context.translate(boundary.minX, boundary.minY);
            drawSquare();
            drawBoundary();
            drawWalls();



  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            You may have noticed that the lesson on
            %code context.translate(x, y)
            calls the method
            = link_to_lesson('context.save()', :save, nil, class: 'reference-link', data: {slug: :save})
            and the method
            %code context.restore()
          %pre
            %code
              :preserve
                function drawFrenchFlag(x, y) {
                  context.save(); // Save the drawing state before making any changes
                  context.translate(x, y); // Move the origin of the coordinate system to the top left corner of the flag

                  ...

                  context.restore(); // Restore the drawing state to the way it was when we saved it
                }
          %p
            We need to call
            %code context.save()
            and
            %code contest.restore()
            in order to reset the canvas origin.
          %p
            If we call
            %code context.translate()
            more than once then each translation will build on top of the last. So this:
          %pre
            %code
              :preserve
                context.translate(20, 20);
                context.translate(20, 20);
                context.translate(20, 20);
                context.fillRect(0, 0, 50, 50);
          %p
            Would cause a square to be drawn at (60, 60).
          %p
            While this isn't causing any problems yet, it will cause problems as soon as
            we begin animating our game (in the next section).
          %p
            So in preparation for the animation let's wrap our translation
            with a call to
            %code context.save()
            and
            %code context.restore()
          %p
            Call
            %code context.save()
            before the translation and then
            %code context.restore()
            once you're done drawing everything.

          %p
            In the end your flappy square game should look just like it did after the last
            challenge.

          = render 'lessons/relevant', relevant: [:save, :translate, :functions, :fill_rect, :coordinates, :variables]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // CODE FROM PREVIOUS CHALLENGE
            // Place context.save() before the translation
            // and context.restore() after everything has been drawn.



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 25,
              y: 75,
              size: 20
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(0, 0, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, 0, wall.width, wall.height);
              context.fillRect(x, boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(125);
              drawWall(125 * 2);
              drawWall(125 * 3);
            }

            context.save();
            context.translate(boundary.minX, boundary.minY);
            drawSquare();
            drawBoundary();
            drawWalls();
            context.restore();



  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Basics of Animation

          .float-xs-right.pl-2.pb-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual.png")

          %p
            There are
            %span.highlight three required aspects to basic animation
            in canvas we need to cover:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.

          %p
            In this lesson we're going to focus on the 1st and 3rd step of basic animation.
          %p
            We're going to draw a series of frames, each a bit different from each other,
            creating the illusion of continuous motion.
          %p
            Drawing frames in rapid sequence can be done a number of ways.
            For our purposes we'll use the
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            method.
            %code setInterval(function, intervalTime)
            runs the specified code at a regular interval (e.g. every second). You can use setInterval in
            two different ways. First you can pass it code directly:

          %pre
            %code
              :preserve
                setInterval(function() {
                  ... some code ...
                }, 500)
          %p
            Or you can pass it a reference to an existing function:
          %pre
            %code
              :preserve
                function myFunction() {
                  ... some code ...
                }

                setInterval(myFunction, 500);

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual2.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small.mb-1
              A slower running animation
              %br
              setInterval(programSteps, 1000)
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual3.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small
              A faster running animation
              %br
              setInterval(programSteps, 10)

          %p
            In this case the function will be called as if you ran
            %code myFunction()
            every 500 milliseconds.

          %p
            We're going to use
            %span.highlight setInterval() to draw frames in rapid sequence.
            We'll pass it a reference to the function
            %code programSteps
            which contains the instructions for each frame of our game.

          %p
            We can change the speed of our animation by adjusting the intervalTime in
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})

          %p For example:
          %pre
            %code
              :preserve
                setInterval(programSteps, 1000)

          %p will run slowly, drawing a new frame every second, while

          %pre
            %code
              :preserve
                setInterval(programSteps, 10)
          %p
            will run very quickly, drawing 100 frames every second. The faster an animation runs
            the smoother it looks as you can draw frames that change very little, giving the
            illusion of continuous motion.
          %p
            Try playing around with different interval speeds to see how it affects the fluidity
            of the animation.


          = render 'lessons/relevant', relevant: [:fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var size = 1;

                function drawSquare() {
                  context.fillRect(0, 100, size, size);
                }

                function adjustSize() {
                  size += 10;
                }

                function programSteps() {
                  adjustSize();
                  drawSquare();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 500);
                }



                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Now we're going to start animating our game.
          %p
            In this challenge we're going to focus on using
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            to animate just our flappy square.
          %p
            We'll make the flappy square move down on the canvas. Soon we'll make
            it's downward movement look more realistic by mathematically simulating
            gravity, but for now we'll just make it move down one step at a time.

          %p
            Use
            %span.highlight setInterval(function, intervalTime),
            as provided to
            %span.highlight draw the flappy square a bit lower in each frame
            as if it were falling.
          %p
            Have your flappy square
            %span.highlight start at (50, 100) and move down 25 pixels every 300 milliseconds.
          %p
            As we are not yet clearing the canvas in between frames we'll be creating multiple
            flappy squares. In the next challenge we'll look at cleaning that up to create
            a true animation.
          %p
            Your animation should look like the example to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :set_interval, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;

            // CODE FROM PREVIOUS CHALLENGE HERE

            function adjustPosition() {
              // ADJUST THE "y" COORDINATE OF THE SQUARE
            }

            function programSteps() {
              adjustPosition();

              context.save();
              context.translate(boundary.minX, boundary.minY);
              drawBoundary();
              drawSquare();
              drawWalls();
              context.restore();
            }

            function runProgram() {

              // FILL IN THE CORRECT setInterval PARAMETERS HERE
              interval = setInterval();

            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 25,
              y: 75,
              size: 20
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(0, 0, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, 0, wall.width, wall.height);
              context.fillRect(x, boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(125);
              drawWall(125 * 2);
              drawWall(125 * 3);
            }


            function adjustPosition() {
              square.y += 25;
            }

            function programSteps() {
              adjustPosition();

              context.save();
              context.translate(boundary.minX, boundary.minY);
              drawBoundary();
              drawSquare();
              drawWalls();
              context.restore();
            }

            function runProgram() {
              interval = setInterval(programSteps, 300);
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();


  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: A Complete Animation Cycle

          .float-xs-right.pl-2.pb-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual.png")

          %p
            As mentioned in the previous lesson, there are
            %span.highlight three required aspects to basic animation:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.
          %p
            In this lesson we're going to complete the cycle by clearing the canvas
            in between frames.
          %p
            The method
            = link_to_lesson('context.clearRect(x, y, width, height)', :clear_rect, nil, class: 'reference-link', data: {slug: :clear_rect})
            allows us to clear an area of the canvas. For our purposes we'll use it to clear the entire canvas.
          %p
            In this example we show the example from the last lesson in reverse. If this were run without
            clearing the canvas you wouldn't see any changes, but since we're clearing the canvas
            in between each frame we see the drawing get smaller and smaller.
          %p In order to clear the entire canvas we use the following code:
          %pre
            %code
              :preserve
                context.clearRect(0, 0, canvas.width, canvas.height);
          %p
            which says "clear an area starting at (0,0) that is as wide as the canvas
            and as tall as the canvas".

          = render 'lessons/relevant', relevant: [:clear_rect, :fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var size = canvas.width;

                function drawSquare() {
                  context.fillRect(0, 0, size, size);
                }

                function adjustSize() {
                  size -= 10;
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  adjustSize();
                  drawSquare();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 500);
                }



                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            As mentioned in the previous lesson, there are
            %span.highlight three required aspects to basic animation:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.
          %p
            In this lesson we're going to complete the cycle by clearing the canvas
            in between frames.
          %p
            The method
            = link_to_lesson('context.clearRect(x, y, width, height)', :clear_rect, nil, class: 'reference-link', data: {slug: :clear_rect})
            allows us to clear an area of the canvas. As the lesson above demonstrates,
            we want to use it to clear the entire canvas.
          %p
            So once again, we'll start the flappy square
            at (50, 100) and move down 10 pixels every 300 milliseconds.
          %p
            This time, though,
            %span.highlight use context.clearRect()
            to clear the canvas in between frames.
          %p
            Use the method to clear a rectangle starting at
            %span.highlight (0, 0)
            with a width of
            %span.highlight canvas.width
            and a height of
            %span.highlight canvas.height.
          %p
            You'll need to call it from within
          %pre
            %code
              :preserve
                function programSteps() {
                  ...
                }
          %p so that it gets called with each frame.
          %p
            Your animation should look like the example at the beginning of this explanation.

          = render 'lessons/relevant', relevant: [:clear_rect, :fill_rect, :set_interval, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;

            // CODE FROM PREVIOUS CHALLENGE HERE
            // JUST FIGURE OUT WHERE TO ADD
            // context.clearRect(0, 0, canvas.width, canvas.height)



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 25,
              y: 75,
              size: 20
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(0, 0, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, 0, wall.width, wall.height);
              context.fillRect(x, boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(125);
              drawWall(125 * 2);
              drawWall(125 * 3);
            }

            function adjustPosition() {
              square.y += 25;
            }

            function programSteps() {
              context.clearRect(0, 0, canvas.width, canvas.height);
              adjustPosition();

              context.save();
              context.translate(boundary.minX, boundary.minY);
              drawBoundary();
              drawSquare();
              drawWalls();
              context.restore();
            }

            function runProgram() {
              interval = setInterval(programSteps, 300);
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();






  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Gravity
          %p
            Now we need to make our flappy square fall more realistically.
          %p
            This essentially requires
            %span.highlight simulating gravity.
          %p
            Gravity causes objects on earth to move toward the center of the Earth
            at an accelerating rate, which means that they move faster and faster
            toward the ground.
          %p
            The speed of the object toward the ground is called its "velocity".
            Gravity causes the object's velocity to increase over time.
          %p
            In this examples when you click "Run" a ball will shoot out at
            a constant velocity moving right and up while gravity pulls it toward
            the ground, causing its upward velocity to decrease until it is negative
            (falling).
          %p
            In this example gravity is set to 0.4. This means that the upward speed (yVelocity)
            of our ball will decrease by 0.4 each frame. So in each frame the ball will move up
            by 0.4 pixels less than the last frame until it is no longer moving at which point
            it will move down by 0.4 pixels more each frame.
          %p
            This is an arbitrary value that simply makes the simulation look good as we're not
            actually trying to simulate gravity accurately.
          %p
            Also remember that in the canvas the "y" coordinates go up as you move down.
            This means that subtracting a negative "yVelocity" from our "y" position actually
            makes our "y" value large, drawing the ball farther down on the canvas.

          = render 'lessons/relevant', relevant: [:coordinates, :clear_rect, :fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var gravity = 0.4;
                var size = 10;
                var interval;
                x = 0;
                y = canvas.height - 60;
                xVelocity = 8;
                yVelocity = 12;

                function drawBall() {
                  context.beginPath();
                  context.arc(x, y, size, 0, Math.PI*2, true);
                  context.closePath();
                  context.fill();
                }

                function adjustPosition() {
                  yVelocity -= gravity;
                  x += xVelocity;
                  y -= yVelocity;
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  adjustPosition();
                  drawBall();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 25);
                }

                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();



            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's give our flappy square animation a more realistic simulation
            of gravity.
          %p
            Using your code from Challenge
            = challenge_index - 1
            instead of just moving the flappy square
            down 25 pixels each frame let's track the y velocity of the flappy
            square and with each frame let's subtract gravity to increase the velocity
            downward.
          %p
            %span.highlight
              Our flappy square should start at (50, 100) with a yVelocity of 0. Gravity
              should be set to 0.5.
            So in each frame you'll subtract gravity from yVelocity and then
            you'll subtract yVelocity to the y variable. This will cause the y variable to
            increase at an increasing rate (making the flappy square go down
            at an increasing rate).
          %p
            Let's also speed up our animation and instead of running a frame every 300
            miliseconds, let's
            %span.highlight draw a frame every 25 miliseconds.
          %p
            Your animation should look like the example to the right.
          %p
            Important note: In Challenge
            = challenge_index - 1
            we added 25 to the "y" variable in each frame causing the square
            to move down. Here we need to
            %span.highlight subtract "yVelocity"
            as "yVelocity" will be negative and subtracting a negative is the same
            as adding a positive (I know this can get confusing with the y-coordinate
            of the canvas moving in the wrong direction).

          = render 'lessons/relevant', relevant: [:coordinates, :clear_rect, :set_interval, :fill_rect, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = ;

            // HASH VARIABLES HERE
            // Remember to store yVelocity in
            // your square hash variable

            function drawBoundary() {
            }

            function drawSquare() {
            }

            function drawWall(x) {
            }

            function drawWalls() {
            }

            function adjustPosition() {
              // Instead of simply adding
              // 25 to the "square.y" variable you'll
              // need to both adjust the "square.yVelocity"
              // and then use it to adjust "square.y"
            }

            function programSteps() {
            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

      .row.pt-2
        = render :layout => '/lessons/code_i_wrote' do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;

            var boundary = {
              minX: 25,
              minY: 25,
              width: 425,
              height: 275
            };

            var square = {
              x: 25,
              y: 75,
              size: 20,
              yVelocity: 0
            };

            var wall = {
              width: 50,
              height: 100
            };

            function drawBoundary() {
              context.strokeRect(0, 0, boundary.width, boundary.height);
            }

            function drawSquare() {
              context.fillRect(square.x, square.y, square.size, square.size);
            }

            function drawWall(x) {
              context.fillRect(x, 0, wall.width, wall.height);
              context.fillRect(x, boundary.height - wall.height, wall.width, wall.height);
            }

            function drawWalls() {
              drawWall(125);
              drawWall(125 * 2);
              drawWall(125 * 3);
            }

            function adjustPosition() {
              square.yVelocity += gravity;
              square.y += square.yVelocity;
            }

            function programSteps() {
              context.clearRect(0, 0, canvas.width, canvas.height);
              adjustPosition();

              context.save();
              context.translate(boundary.minX, boundary.minY);
              drawBoundary();
              drawSquare();
              drawWalls();
              context.restore();
            }

            function runProgram() {
              interval = setInterval(programSteps, 25);
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();
