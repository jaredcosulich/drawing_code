- stage_index = 1
- section_index = 0
- lesson_index = 0
- challenge_index = 0

#flappy_square_stage1.page
  %h1 Stage 1

  .description.row.py-3
    .col-xs-6
      %h2.py-2
        Flappy Square Overview
      %p
        In the Flappy Square challenge we'll create a simplified version
        of the popular mobile game,
        = "#{link_to('Flappy Birds', 'https://www.flappybird.com/', target: '_blank')}.".html_safe
      %p
        For our game we won't be creating any fancy graphics, we'll simply have
        a square that flies when you click on the canvas with the mouse and falls when you
        don't. You'll have to navigate through randomly generated walls in the course
        by flying to the correct height to pass through the hole.

    .col-xs-6
      = image_tag('flappy_square.gif', class: 'img-fluid')

  .description.row.py-3
    .col-xs-6
      %h2.py-2
        Stage 1 Overview
      %p
        In the first stage of the Flappy Square challenge we'll focus
        on drawing the basic elements of our game: the flappy square,
        the boundary of the game, and one wall.
    .col-xs-6
      = image_tag("lessons/flappy_square/stage#{stage_index}/overview.png", class: 'img-fluid canvas-example')

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: The Coordinate System

          .float-xs-right.mx-2
            = image_tag('lessons/coordinates/reference.png', class: 'img-fluid')

          %p
            Before we get started with our game it is important to understand
            the coordinate system we'll be drawing in.
          %p
            When drawing in the
            = link_to_lesson('coordinate system', :coordinates, nil, class: 'reference-link', data: {slug: :coordinates})
            on a canvas element (as seen to the right) the
            %span.highlight "y" values go down.
          %p
            Unlike with a normal graph, where the positive "y" values go up starting from the bottom, in the canvas
            positive "y" values go down starting from the top.
          %p
            So the point (50, 100) is 50 pixels from the right of the top left corner of the canvas and
            100 pixels down from the top left corner.
          %p
            In the example below, we are drawing two squares that are
            %span.highlight 25 pixels wide and 25 pixels high
            using the
            = link_to_lesson('context.fillRect(x, y, width, height)', :fill_rect, nil, class: 'reference-link', data: {slug: :fill_rect})
            method. The
            %span.highlight black square is at (0, 0)
            so it's top left corner is in the top left corner of the canvas. The
            %span.highlight blue square is at (50, 100)
            so it's top left corner is 50 pixels to the right and 100 pixels down.
          %p
            Try adjusting the coordinates of the two squares and see how they move around
            the coordinate system.
          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                context.fillRect(0, 0, 25, 25);

                context.fillStyle = 'blue';
                context.fillRect(50, 100, 25, 25);


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Draw a rectangle using the
            = link_to_lesson('context.fillRect(x, y, width, height)', :fill_rect, nil, class: 'reference-link', data: {slug: :fill_rect})
            method where you replace x with the top left x coordinate, y with the top left y coordinate,
            width with the width of the rectangle and height with the height of the rectangle.
          %p
            Draw the rectangle so that it's top left corner is 90px down from the top of the canvas
            and 60px over from the left of the canvas. The rectangle should be 60px tall (height) and
            45px wide (width).

          %p In the end your drawing should look like the example provided to the right.
          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // YOUR CODE HERE

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Draw The Flappy Square
          %p
            In our game our flying square will be just that, a simple square.
          %p
            In this example, we'll draw a simple square using
            = link_to_lesson('context.fillRect(x, y, width, height)', :fill_rect, nil, class: 'reference-link', data: {slug: :fill_rect})
            that is
            %span.highlight 50 pixels wide and 50 pixels tall.
            We'll position it so that its
            %span.highlight top left corner is at x = 100, y = 50: (100, 50).
          %p
            Remember: In the context's
            = link_to_lesson('coordinate system', :coordinates, nil, class: 'reference-link', data: {slug: :coordinates})
            the origin (0, 0) is at the top left corner of the canvas.
          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                context.fillRect(100, 50, 50, 50);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Draw a flappy square that is
            %span.highlight 20 pixels wide and 20 pixels tall
            and position it at
            %span.highlight (50, 100).

          %p In the end your flappy square should look like the example provided to the right.
          = render 'lessons/relevant', relevant: [:coordinates, :fill_rect]

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // YOUR CODE HERE

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Using beginPath(), lineTo(), and stroke()
          %p
            We're going to want to create a "game area" for our game which
            is essentially just a rectangle drawn within the canvas
            that represents the valid area for the game to be drawn in.
          %p
            But we don't want our square to be filled in, so
            = link_to_lesson('context.fillRect()', :fill_rect, nil, class: 'reference-link', data: {slug: :fill_rect})
            won't work. We'll need to use
            = link_to_lesson('context.lineTo()', :line_to, nil, class: 'reference-link', data: {slug: :line_to})
            to draw a line and outline a rectangle.
          %p
            Unfortunately the
            = link_to_lesson('context.lineTo()', :line_to, nil, class: 'reference-link', data: {slug: :line_to})
            method is a bit more compicated than the
            %code context.fillRect()
            method.
          %p
            When drawing a line you first trace the path using
            %code context.beginPath()
            %code context.moveTo()
            %code context.lineTo()
            and
            %code context.closePath();
            and then you paint the path using
            %code context.stroke()
          %p
            Essentially all the commands (beginPath(), moveTo(), lineTo(), and closePath()) are being
            used to trace and invisible path within the canvas. The
            %code context.stroke()
            method tells the canvas to paint the line. You could have also called
            %code context.fill()
            to fill in the traced out area.
          %p
            Look at this example to see how these methods
            are used to draw a triangle. You can also click on the
            "lineTo()" button below in the "Relevant Lessons" section to see more details.
          = render 'lessons/relevant', relevant: [:coordinates, :line_to]


        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                context.beginPath();
                context.moveTo(50, 200);
                context.lineTo(200, 50);
                context.lineTo(350, 200);
                context.closePath();
                context.stroke();

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's take the code from Challenge
            = challenge_index - 1
            and add a boundary for our game.
          %p
            The boundary should
            %span.highlight start at (25, 25) and extend to (450, 300),
            forming a rectangle. Use
            %code context.lineTo()
            to draw the boundary. Be sure to use
            %code context.beginPath()
            %code context.moveTo()
            and
            %code context.stroke()
            as described in the lesson above.

          %p In the end our game should look like the example provided to the right.
          = render 'lessons/relevant', relevant: [:line_to, :fill_rect, :coordinates]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // YOUR PREVIOUS FLAPPY SQUARE CODE

            // YOUR NEW CODE FOR A GAME BOUNDARY



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's take a look at the walls in our game.
          %p
            Eventually we'll need to create many walls, animate them, randomize them,
            and track them to make sure that we are not running into the them.
          %p
            Let's start, though, by simply creating one wall. We'll create one rectangles
            that is attached to the roof of the game area with a matching rectangle on
            the floor of the game area.
          %p
            So try to draw two rectangles (a wall), one attached to the
            %span.highlight roof (y = 50)
            and one to the
            %span.highlight floor (y = 300)
            Each of them should be
            %span.highlight 100 pixels tall and 50 pixels wide.
          %p
            We also don't want to draw our walls right on top of the flappy square
            when the game starts, so let's draw this first one
            %span.highlight 125 pixels out
            from the left wall of the game.
          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates, :line_to]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            // CODE FOR YOUR FLAPPY SQUARE

            // CODE FOR YOUR GAME BOUNDARY

            // CODE FOR YOUR WALL


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.pt-2
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Using Variables

          %p
            There are a lot of numbers in our game and many of them are dependent on each other.
          %p
            For example if we want to place our first wall 125 pixels from the left border
            of our game area then it would be nice to be able to reference the left border
            "x" position when we draw our first wall.
          %p
            %span.highlight
              Variables allow us to store information and
              reference / manipulate that information later.
          %p
            Variable are a core concept in software development. If you feel uncertain about them
            you should click on the "variables" quick reference button below and click on the
            "Full Lesson" button in the pop-up.
          %p
            In this example we use a variable to position a square
            %span.highlight 150 pixels
            from a left hand border.

          = render 'lessons/relevant', relevant: [:variables, :coordinates, :fill_rect, :line_to]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#stage_index_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var wallX = 50;
                var wallY = 50;
                var wallHeight = 200;

                var squareX = wallX + 150;
                var squareY = 100;
                var squareSize = 50;

                context.beginPath();
                context.moveTo(wallX, wallY);
                context.lineTo(wallX, wallY + wallHeight);
                context.stroke();

                context.fillRect(squareX, squareY, squareSize, squareSize);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Use
            %span.highlight
              = link_to_lesson('variables', :variables, nil, class: 'reference-link', data: {slug: :variables})
              to capture the various aspects of your flappy square, boundary, and first wall.
          %p
            Setting a variable looks like this:

          %pre
            %code
              :preserve
                var wallX = 25;

          %p
            We've provided the variables for the boundary. You can se the variables
            for the flappy square and the boundary.
          %p
            As a reminder the flappy square should be positioned at
            %span.highlight (50, 100)
            and should be
            %span.highlight 20 pixels wide and 20 pixels tall.
          %p
            The wall should be
            %span.highlight 50 pixels wide and 100 pixels tall
            and should be attached to the top and bottom of the boundary.
          %p
            To work with our variable effectively let's reposition our wall
            %span.highlight 100 pixels
            from the left boundary instead of 125 pixels.
          %p
            Variable are a core concept in software development. If you feel uncertain about them
            you should click on the "variables" quick reference button below and click on the
            "Full Lesson" button in the pop-up.
          %p
            In the end your game should look like the image provided above.

          = render 'lessons/relevant', relevant: [:variables, :coordinates, :fill_rect, :line_to]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var boundaryMinX = 25;
            var boundaryMinY = 25;
            var boundaryMaxX = 450;
            var boundaryMaxY = 300;

            var squareX = ;
            var squareY = ;
            var squareSize = ;

            // WALL VARIABLES HERE

            // CODE FOR YOUR FLAPPY SQUARE

            // CODE FOR YOUR GAME BOUNDARY

            // CODE FOR YOUR WALL


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert

  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - challenge_index += 1
  .challenge.row.py-4{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.png", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            A best practice in coding is to try and not repeat yourself.
          %p
            One of the most powerful aspects of coding is how you can create
            structures of information and functionality that can be reused
            in different ways.
          %p
            In our code right now are variables look very similar:
          %pre
            %code
              :preserve
                var boundaryMinX = 25;
                var boundaryMinY = 25;
                var boundaryMaxX = 450;
                var boundaryMaxY = 300;
          %p
            Those four variable declations all repeat the word "boundary".
          %p
            Instead we could use a hash, which is a way to store information,
            to collect all of these variables together.
          %p
            This would look like this:
          %pre
            %code
              :preserve
                var boundary = {
                  minX: 25,
                  minY: 25,
                  maxX: 450,
                  maxY: 300
                }
          %p
            This makes it a bit easier to read our code and reduces a lot of
            unnecessary duplication.
          %p
            Rewrite your code from the previous challenge using this format.
          %p
            Let's also set the wall's "x" position back to 125 pixels from the
            left boundary.
          %p
            In the end your game should look like the image provided above.

          = render 'lessons/relevant', relevant: [:variables, :coordinates, :fill_rect, :line_to]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var boundary = {
              // SET THE DETAILS OF YOUR BOUNDARY HASH HERE
            };

            // SQUARE HASH HERE

            // WALL HASH HERE

            // CODE FOR YOUR FLAPPY SQUARE

            // CODE FOR YOUR GAME BOUNDARY

            // CODE FOR YOUR WALL


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}.png")
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert


-#
  - section_index += 1
  .section.py-2{id: "section#{section_index}"} &nbsp;

  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Algorithmic Objects
          %p
            Our game needs a background. Really it needs a series of walls with holes
            in them that are randomly generated, but this is akin to a background
            that is generated by the code, so we'll start there.
          %p
            Since there will be essentially an unlimited number of walls in our game we'll need to
            create them algorithmically. This means that rather than explicitly
            writing code that draws these walls, which would take forever,
            we need to write code that itself determines where the walls should go.
          %p
            In this example we show a series of trees which serves as a background.
            We could call our drawTree() method explicitly like this:
          %pre
            %code
              :preserve
                var treeY = canvas.height - road.height;
                drawTree(50, treeY);
                drawTree(80, treeY);
                drawTree(110, treeY);
                drawTree(140, treeY);
                ... etc, etc ...
          %p
            Or we could draw trees algorithmically, drawing them every 75 pixels until
            the end of the canvas is reached. This would look like:
          %pre
            %code
              :preserve
                var treeSpacing = 75;
                var treeX = 0;
                var treeY = canvas.height - road.height;
                while (treeX < canvas.width) {
                  drawTree(treeX, treeY);
                  treeX += treeSpacing;
                }
          %p
            This code starts at
            %code treeX = 0
            and loops over and over, drawing one tree each time while also
            adding 75 (treeSpacing) to treeX while treeX is less than the width of the
            canvas plus treeSpacing (to account for trees on the border).
          %p
            Check out the lesson on
            = link_to_lesson('while loops', :while_loops, nil, class: 'reference-link', data: {slug: :while_loops})
            to better understand how these loops work.
          %p
            The example below uses this code to draw our trees algorithmically, drawing
            a tree every 75 pixels.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates, :while_loops]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var road = {
                  height: 30
                };

                var tree = {
                  spacing: 75
                };

                function drawRoad() {
                  context.save();
                  context.fillStyle = '#cccccc';
                  var roadY = canvas.height - road.height;
                  context.fillRect(0, roadY, canvas.width, road.height);
                  context.restore();
                }

                function drawGrass() {
                  context.save();
                  context.fillStyle = '#238d23';
                  var grassHeight = 6;
                  var grassY = canvas.height - road.height - grassHeight;
                  context.fillRect(0, grassY, canvas.width, grassHeight);
                  context.restore();
                }

                function drawTrees() {
                  var treeX = 0;
                  var treeY = canvas.height - road.height;
                  while (treeX < canvas.width + tree.spacing) {
                    drawTree(treeX, treeY);
                    treeX += tree.spacing;
                  }
                }

                function drawTree(centerX, bottomY) {
                  context.save();
                  context.translate(centerX, bottomY);
                  context.fillStyle = '#a5681c';
                  context.fillRect(0, -60, 12, 60);

                  context.beginPath();
                  context.arc(6, -60, 32, 0, Math.PI*2, true);
                  context.closePath();
                  context.fillStyle = '#238d23';
                  context.fill();

                  context.restore();
                }

                drawRoad();
                drawGrass();
                drawTrees();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.pl-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's add walls to our game.
          %p
            Eventually we'll need to animate these walls, randomize them,
            and track them to make sure that we are not running into the them.
          %p
            Let's start, though, by simply adding a series of rectangles to the roof
            of the game area with matching rectangles on the floor of the game area.
          %p
            So try to draw two rectangles (a wall), one attached to the
            %span.highlight roof (y = 50)
            and one to the
            %span.highlight floor (y = 300)
            Each of them should be
            %span.highlight 100 pixels tall and 50 pixels wide.
            and each wall should be spaced
            %span.highlight 125 pixels
            from the previous wall's "x" coordinate.
          %p
            We also don't want to draw our walls right on top of the flappy square
            when the game starts, so let's draw the first one
            %span.highlight 125 pixels out
            from the left wall of the game (boundary.minX).
          %p In the end your flappy square should behave like the example provided to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :coordinates]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = 0.5;

            var square = {
              size: 20,
              x: ,
              y: ,
              jump: ,
              yVelocity:
            };

            var boundary = {
              minX: ,
              minY: ,
              maxX: ,
              maxY:
            };

            var walls = {
              height: ,
              width: ,
              spacing:
            };

            function drawBoundary() {
            }

            function drawWalls() {

              // Draw your walls here.

            }

            function drawSquare() {
            }

            function flap(e) {
            }

            function adjustPosition() {
            }

            function checkBoundary() {
            }

            function endGame() {
              context.font = "20px serif";
              context.textAlign = 'center';

              var xCenter = ((boundary.maxX - boundary.minX) / 2) + boundary.minX;
              var yCenter = ((boundary.maxY - boundary.minY) / 2) + boundary.minY;
              context.fillText('Game Over', xCenter, yCenter);

              pauseAnimation();
            }

            function programSteps() {

              // Don't forget to draw the walls!

            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();


        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert











  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Basics of Animation

          .float-xs-right.pl-2.pb-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual.png")

          %p
            There are
            %span.highlight three required aspects to basic animation
            in canvas we need to cover:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.

          %p
            In this lesson we're going to focus on the 1st and 3rd step of basic animation.
          %p
            We're going to draw a series of frames, each a bit different from each other,
            creating the illusion of continuous motion.
          %p
            Drawing frames in rapid sequence can be done a number of ways.
            For our purposes we'll use the
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            method.
            %code setInterval(function, intervalTime)
            runs the specified code at a regular interval (e.g. every second). You can use setInterval in
            two different ways. First you can pass it code directly:
          %pre
            %code
              :preserve
                setInterval(function() {
                  ... some code ...
                }, 500)
          %p
            Or you can pass it a reference to an existing function:
          %pre
            %code
              :preserve
                function myFunction() {
                  ... some code ...
                }

                setInterval(myFunction, 500);
          %p
            In this case the function will be called as if you ran
            %code myFunction()
            every 500 milliseconds.

          %p
            We're going to use
            %span.highlight setInterval() to draw frames in rapid sequence.
            We'll pass it a reference to the function
            %code programSteps
            which contains the instructions for each frame of our game.
          %p
            We can change the speed of our animation by adjusting the intervalTime in
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
          %p For example:
          %pre
            %code
              :preserve
                setInterval(programSteps, 1000)
          %p will run slowly, drawing a new frame every second, while
          %pre
            %code
              :preserve
                setInterval(programSteps, 10)
          %p
            will run very quickly, drawing 100 frames every second. The faster an animation runs
            the smoother it looks as you can draw frames that change very little, giving the
            illusion of continuous motion.
          %p
            Try playing around with different interval speeds to see how it affects the fluidity
            of the animation.


          = render 'lessons/relevant', relevant: [:fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var size = 1;

                function drawSquare() {
                  context.fillRect(0, 100, size, size);
                }

                function adjustSize() {
                  size += 10;
                }

                function programSteps() {
                  adjustSize();
                  drawSquare();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 500);
                }



                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            In this challenge we're going to use
            = link_to_lesson('setInterval(function, intervalTime)', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            to animate our flappy square.
          %p
            Use
            %span.highlight setInterval(function, intervalTime),
            called from the canvas "focus" event, to
            %span.highlight draw the flappy square a bit lower in each frame
            as if it were falling.
          %p
            Have your flappy square
            %span.highlight start at (50, 100) and move down 25 pixels every 300 milliseconds.
          %p
            Your animation should look like the example to the right.

          = render 'lessons/relevant', relevant: [:fill_rect, :set_interval, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var size = 20;

            // SET YOUR POSITION VARIABLES HERE
            var x =
            var y =

            function drawSquare() {

              // YOUR CODE FOR DRAWING A SQUARE HERE

            }

            function adjustPosition() {

              // YOUR CODE FOR CHANGING THE POSITION OF THE SQUARE HERE

            }

            function programSteps() {
              adjustPosition();
              drawSquare();
            }

            function runProgram() {

              // FILL IN THE CORRECT setInterval PARAMETERS HERE
              interval = setInterval();

            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert



  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: A Complete Animation Cycle

          .float-xs-right.pl-2.pb-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/lesson#{lesson_index}Visual.png")

          %p
            As mentioned in the previous lesson, there are
            %span.highlight three required aspects to basic animation:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.
          %p
            In this lesson we're going to complete the cycle by clearing the canvas
            in between frames.
          %p
            The method
            = link_to_lesson('context.clearRect(x, y, width, height)', :clear_rect, nil, class: 'reference-link', data: {slug: :clear_rect})
            allows us to clear an area of the canvas. For our purposes we'll use it to clear the entire canvas.
          %p
            In this example we show the example from the last lesson in reverse. If this were run without
            clearing the canvas you wouldn't see any changes, but since we're clearing the canvas
            in between each frame we see the drawing get smaller and smaller.
          %p In order to clear the entire canvas we use the following code:
          %pre
            %code
              :preserve
                context.clearRect(0, 0, canvas.width, canvas.height);
          %p
            which says "clear an area starting at (0,0) that is as wide as the canvas
            and as tall as the canvas".

          = render 'lessons/relevant', relevant: [:clear_rect, :fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var interval;
                var size = canvas.width;

                function drawSquare() {
                  context.fillRect(0, 0, size, size);
                }

                function adjustSize() {
                  size -= 10;
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  adjustSize();
                  drawSquare();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 500);
                }



                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();


            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            As mentioned in the previous lesson, there are
            %span.highlight three required aspects to basic animation:
          %ul
            %li Drawing frames in rapid sequence.
            %li Clearing the canvas in between frames.
            %li Making small changes to the scene in each frame.
          %p
            In this lesson we're going to complete the cycle by clearing the canvas
            in between frames.
          %p
            The method
            = link_to_lesson('context.clearRect(x, y, width, height)', :clear_rect, nil, class: 'reference-link', data: {slug: :clear_rect})
            allows us to clear an area of the canvas. As the lesson above demonstrates,
            we want to use it to clear the entire canvas.
          %p
            So once again, we'll start the flappy square
            at (50, 100) and move down 10 pixels every 300 milliseconds.
          %p
            This time, though,
            %span.highlight use context.clearRect()
            to clear the canvas in between frames.
          %p
            Use the method to clear a rectangle starting at
            %span.highlight (0, 0)
            with a width of
            %span.highlight canvas.width
            and a height of
            %span.highlight canvas.height.
          %p
            You'll need to call it from within
          %pre
            %code
              :preserve
                function programSteps() {
                  ...
                }
          %p so that it gets called with each frame.
          %p
            Your animation should look like the example at the beginning of this explanation.

          = render 'lessons/relevant', relevant: [:clear_rect, :fill_rect, :set_interval, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var size = 20;

            var x = 50;
            var y = 100;

            function drawSquare() {
              context.fillRect(x, y, size, size);
            }

            function adjustPosition() {
              y += 10;
            }

            function programSteps() {
              adjustPosition();
              drawSquare();
            }

            function runProgram() {
              interval = setInterval(programSteps, 300);
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert



  - lesson_index += 1
  .lesson.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Lesson: Gravity
          %p
            Now we need to make our flappy square fall more realistically.
          %p
            This essentially requires
            %span.highlight simulating gravity.
          %p
            Gravity causes objects on earth to move toward the center of the Earth
            at an accelerating rate, which means that they move faster and faster
            toward the ground.
          %p
            The speed of the object toward the ground is called its "velocity".
            Gravity causes the object's velocity to increase over time.
          %p
            In this examples when you click "Run" a ball will shoot out at
            a constant velocity moving right and up while gravity pulls it toward
            the ground, causing its upward velocity to decrease until it is negative
            (falling).
          %p
            In this example gravity is set to 0.4. This means that the upward speed (yVelocity)
            of our ball will decrease by 0.4 each frame. So in each frame the ball will move up
            by 0.4 pixels less than the last frame until it is no longer moving at which point
            it will move down by 0.4 pixels more each frame.
          %p
            This is an arbitrary value that simply makes the simulation look good as we're not
            actually trying to simulate gravity accurately.
          %p
            Also remember that in the canvas the "y" coordinates go up as you move down.
            This means that subtracting a negative "yVelocity" from our "y" position actually
            makes our "y" value large, drawing the ball farther down on the canvas.

          = render 'lessons/relevant', relevant: [:coordinates, :clear_rect, :fill_rect, :set_interval, :functions]

        .col-xs-12
          .interactive.focus-on-run.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_lesson#{lesson_index}_editor"} do
              :preserve
                var canvas = document.getElementById('flappy_square_stage#{stage_index}_lesson#{lesson_index}');
                var context = canvas.getContext('2d');

                var gravity = 0.4;
                var size = 10;
                var interval;
                x = 0;
                y = canvas.height - 60;
                xVelocity = 8;
                yVelocity = 12;

                function drawBall() {
                  context.beginPath();
                  context.arc(x, y, size, 0, Math.PI*2, true);
                  context.closePath();
                  context.fill();
                }

                function adjustPosition() {
                  yVelocity -= gravity;
                  x += xVelocity;
                  y -= yVelocity;
                }

                function programSteps() {
                  context.clearRect(0, 0, canvas.width, canvas.height);
                  adjustPosition();
                  drawBall();
                }

                function runProgram() {
                  interval = setInterval(programSteps, 25);
                }

                // The following code is provided for you.
                // It creates an eventListener that listens
                // for the canvas to come into "focus", which
                // happens when you click on it.
                // This allows us to stop and start each individual
                // animation on this whole page separately.
                function startAnimation() {
                  runProgram();
                }

                function pauseAnimation() {
                  clearInterval(interval);

                  context.font = "20px serif";
                  context.textAlign = 'center';
                  context.fillText('Click anywhere on the canvas to start animation', canvas.width / 2, 50);
                  context.fillText('or click "Run" to restart the animations.', canvas.width / 2, 75);
                }

                canvas.addEventListener('focus', startAnimation);
                canvas.addEventListener('blur', pauseAnimation);
                pauseAnimation();



            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas{id: "flappy_square_stage#{stage_index}_lesson#{lesson_index}"}

  - challenge_index += 1
  .challenge.row.py-3{id: "challenge#{challenge_index}"}
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            = "Challenge #{challenge_index}"

          %figure.float-xs-right.px-2
            = image_tag("lessons/flappy_square/stage#{stage_index}/challenge#{challenge_index}Example.gif", class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small= "Challenge #{challenge_index} Sample Solution"

          %p
            Let's give our flappy square animation a more realistic simulation
            of gravity.
          %p
            Using your code from Challenge 4, instead of just moving the flappy square
            down 10 pixels each frame let's track the y velocity of the flappy
            square and with each frame let's subtract gravity to increase the velocity
            downward.
          %p
            %span.highlight
              Our flappy square should start at (50, 100) with a yVelocity of 0. Gravity
              should be set to 0.5.
            So in each frame you'll subtract gravity from yVelocity and then
            you'll subtract yVelocity to the y variable. This will cause the y variable to
            increase at an increasing rate (making the flappy square go down
            at an increasing rate).
          %p
            Let's also speed up our animation and instead of running a frame every 300
            miliseconds, let's
            %span.highlight draw a frame every 25 miliseconds.
          %p
            Your animation should look like the example to the right.
          %p
            Important note: In Challenge
            = challenge_index - 1
            we added 10 to the "y" variable in each frame causing the square
            to move down. Here we need to
            %span.highlight subtract "yVelocity"
            as "yVelocity" will be negative and subtracting a negative is the same
            as adding a positive (I know this can get confusing with the y-coordinate
            of the canvas moving in the wrong direction).

          = render 'lessons/relevant', relevant: [:coordinates, :clear_rect, :set_interval, :fill_rect, :functions]
          = render 'lessons/code_preview', stage: stage_index, challenge: challenge_index - 1, editor_id: "flappy_square_stage#{stage_index}_challenge#{challenge_index - 1}_editor"

      .row.pt-2
        = render :layout => '/lessons/editor', :locals => {:editor_id => "flappy_square_stage#{stage_index}_challenge#{challenge_index}_editor"} do
          :preserve
            var canvas = document.getElementById('flappy_square_stage#{stage_index}_challenge#{challenge_index}');
            var context = canvas.getContext('2d');

            var interval;
            var gravity = ;
            var size = 20;
            var x = ;
            var y = ;
            var yVelocity = ;

            function drawSquare() {
            }

            function adjustPosition() {
              // Instead of simply subtracting
              // 10 from the "y" variable you'll
              // need to both adjust the "yVelocity"
              // and then use it to adjust "y"
            }

            function programSteps() {
            }

            function runProgram() {
              interval =
            }



            // The following code is provided for you.
            // It creates an eventListener that listens
            // for the canvas to come into "focus", which
            // happens when you click on it.
            // This allows us to stop and start each individual
            // animation on this whole page separately.
            function startAnimation() {
              runProgram();
            }

            function pauseAnimation() {
              clearInterval(interval);
            }

            canvas.addEventListener('focus', startAnimation);
            canvas.addEventListener('blur', pauseAnimation);
            canvas.focus();



        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas{id: "flappy_square_stage#{stage_index}_challenge#{challenge_index}"}
          .alert
