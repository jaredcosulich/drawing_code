#animated_cityscape_stage2.page
  %h1
    Stage 2
  .description.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Overview
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/overviewVisual1.png', class: 'img-fluid')
          %p
            In the second stage of the Animated Cityscape Challenge, we draw the
            buildings in front of the sky. Because we have to redraw the buildings
            every time the sky is redrawn, we store the data needed to redraw each
            building in an object and each row of buildings in an array.


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Store Data in Objects
          %p
            In this example, we draw three blue squares on top of a yellow background.
          %p
            We start by declaring four global variables: <code>counter</code>,
            <code>squareA</code>, <code>squareB</code>, and <code>squareC</code>.
            We use <code>counter</code> to keep track of the number of times we have
            updated the scene and the three square variables to store the data needed
            to redraw the squares after each update.
          %pre
            %code
              :preserve
                var counter;
                var squareA, squareB, squareC;
          %p
            When the page first loads, the program calls the <code>initScene()</code> function
            and adds an event listener to the canvas. The event listener automatically calls the
            <code>updateScene()</code> function whenever a mouse click is detected on the canvas.
          %pre
            %code
              :preserve
                initScene();
                canvas.addEventListener('click', updateScene);
          %p
            Inside the <code>initScene()</code> function, we initialize the four variables
            and then call the <code>drawScene()</code> function.
          %pre
            %code
              :preserve
                function initScene() {
                  counter = 0;
                  squareA = {x: 200, y:  40, s: 60};
                  squareB = {x:  80, y: 120, s: 40};
                  squareC = {x: 240, y: 220, s: 80};
                  
                  drawScene();
                }
          %p
            The variable <code>squareA</code> is initialized as an object with three
            properties: <code>x</code>, <code>y</code>, and <code>s</code>. An object is
            simply a collection of properties, where each property has a name (or key) and
            a value. In this case, the <code>x</code> property in object <code>squareA</code>
            is assigned the value <code>200</code>.
          %p
            Inside the <code>drawScene()</code> function, we draw the yellow background
            (covering the previous scene) with the frame number and then draw the three
            squares. We draw each square by passing the object storing its data into the
            <code>drawSquare()</code> function as a parameter.
          %pre
            %code
              :preserve
                function drawScene() {
                  drawBackground();
                  drawSquare(squareA);
                  drawSquare(squareB);
                  drawSquare(squareC);
                }
          %p
            Inside the <code>drawSquare()</code> function, the object passed into the function
            is stored in the parameter <code>square</code>. We access the values stored in the
            object's properties using dot notation. For example, to access the value stored in
            the object's <code>x</code> property, we use <code>square.x</code>.
          %pre
            %code
              :preserve
                function drawSquare(square) {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(square.x, square.y, square.s, square.s); // Use the data in the object square to draw the square
                  context.restore();
                }
          %p
            The <code>updateScene()</code> function is called automatically whenever a
            mouse click is detected on the canvas. Inside the <code>updateScene()</code>
            function, we increase the value stored in the <code>counter</code> by 1, decrease
            the values stored in the <code>squareA.x</code> and <code>squareC.y</code>
            properties by 5, and increase the value stored in the <code>squareB.x</code>
            property by 5 before redrawing the scene. Because we are drawing the yellow
            background over the previous scene, the squares look like they are moving.
          %pre
            %code
              :preserve
                function updateScene() {
                  counter += 1;
                  squareA.x -= 5; // This is a shorter way of writing squareA.x = squareA.x - 5
                  squareB.x += 5;
                  squareC.y -= 5;
                  drawScene();
                }
          %p
            Click on the canvas to see the scene update. Change the values stored in the
            objects to change the size and position of the squares. To learn more about objects,
            visit the
            = link_to_lesson('Objects', :objects, nil, class: 'reference-link', data: {slug: :objects})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :objects, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example1_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example1');
                var context = canvas.getContext('2d');
                
                var counter;
                var squareA, squareB, squareC;
                
                initScene();
                canvas.addEventListener('click', updateScene);
                
                function initScene() {
                  counter = 0;
                  squareA = {x: 200, y:  40, s: 60};
                  squareB = {x:  80, y: 120, s: 40};
                  squareC = {x: 240, y: 220, s: 80};
                  
                  drawScene();
                }
                
                function drawScene() {
                  drawBackground();
                  drawSquare(squareA);
                  drawSquare(squareB);
                  drawSquare(squareC);
                }
                
                function updateScene() {
                  counter += 1;
                  squareA.x -= 5; // This is a shorter way of writing squareA.x = squareA.x - 5
                  squareB.x += 5;
                  squareC.y -= 5;
                  drawScene();
                }
                
                function drawSquare(square) {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(square.x, square.y, square.s, square.s); // Use the data in the object square to draw the square
                  context.restore();
                }
                
                function drawBackground() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = '#CCCCCC';
                  context.font = '48px Arial';
                  context.fillText('Frame: ' + counter, 10, 48); // Print the number of the frame on the background
                  context.restore();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example1


  #challenge1.challenge.row.py-3
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 1
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/challenge1Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Even though we aren't moving the buildings in the Animated Cityscape
            Challenge, we still need to redraw them every time we redraw the sky
            because the new sky will cover over everything previously drawn on the
            canvas. And to redraw the buildings, we need to store the data used to
            draw each building.
          %p.pb-1
            Inside the <code>initScene()</code> function, initialize the three variables,
            <code>buildingA</code>, <code>buildingB</code>, and <code>buildingC</code>, as
            objects with the property names and values listed below. Then, draw the scene.
          %table
            %tr
              %td
                <code>buildingA</code>:
                %ul
                  %li
                    leftX: 6,
                  %li
                    groundY: 300,
                  %li
                    w: 88,
                  %li
                    h: 200,
                  %li
                    units: 5,
                  %li
                    floors: 12,
                  %li
                    windowType: 3,
                  %li
                    roofType: 2
              %td.px-2
                <code>buildingB</code>:
                %ul
                  %li
                    leftX: 106,
                  %li
                    groundY: 300,
                  %li
                    w: 168,
                  %li
                    h: 136,
                  %li
                    units: 10,
                  %li
                    floors: 8,
                  %li
                    windowType: 2,
                  %li
                    roofType: 1
              %td
                <code>buildingC</code>:
                %ul
                  %li
                    leftX: 286,
                  %li
                    groundY: 300,
                  %li
                    w: 72,
                  %li
                    h: 248,
                  %li
                    units: 4,
                  %li
                    floors: 15,
                  %li
                    windowType: 0,
                  %li
                    roofType: 0
          %p.pt-1
            Note how we are declaring <code>buildingA</code>, <code>buildingB</code>, and
            <code>buildingC</code> as global variables. This is important because, if we
            declared the three variables inside the <code>initScene()</code> function, they
            would no longer exist once the function ends. By declaring them globally, they
            persist and can be accessed from within other functions.
          %p
            Inside the <code>drawScene()</code> function, declare and initialize the
            variables <code>buildingColor</code> and <code>windowColor</code> with the
            colors <code>'rgb(153, 153, 153)'</code> and <code>'rgb(102, 102, 102)'</code>,
            respectively. Then, draw the three buildings by passing the object that contains
            each building's data into the <code>drawBuilding()</code> function along with
            <code>buildingColor</code> and <code>windowColor</code>.
          %p
            Finally, change the <code>drawBuilding()</code> function's definition so it now
            accepts three parameters instead of ten. Instead of passing values for the
            building's left x-coordinate, ground y-coordinate, width, height, number of office
            units, number of floors, window type, and roof type into the function separately,
            we are going to pass all of those values as properties stored in a single object,
            <code>b</code>.
          %pre
            %code
              :preserve
                function drawBuilding(b, buildingColor, windowColor) {
                  
                  // code block
                  
                }
          %p
            Then, go through the <code>drawBuilding()</code> function and replace any
            references to the deleted parameters with references to the building object's
            properties. For example, the building's left x-coordinate is now stored in
            the <code>b.leftX</code> property, not in the <code>leftX</code> parameter,
            which no longer exists.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :for_loops, :objects, :fill_rect, :fill_style]

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge1_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge1');
            var context = canvas.getContext('2d');
            
            var buildingA, buildingB, buildingC;
            
            initScene();
            
            function initScene() {
              
              // Initialize the three building variables
              // Draw the scene
              
            }
            
            function drawScene() {
              
              // Declare and intialize the buildingColor and windowColor variables
              // Draw the three buildings by passing the data for each building in the drawBuilding() function
              
            }
            
            function drawBuilding(leftX, groundY, w, h, units, floors, windowType, roofType, buildingColor, windowColor) {
              var x = leftX;
              var y = groundY - h;
              
              context.save();
              context.translate(x, y);
              context.fillStyle = buildingColor;
              context.fillRect(0, 0, w, h);
              drawRoof(w, roofType);
              
              context.translate(4, 4);
              context.fillStyle = windowColor;
              
              for (var i = 0; i < floors; i += 1) {
                context.save();
                
                for (var j = 0; j < units; j += 1) {
                  drawWindow(windowType);
                  context.translate(16, 0);
                }
                
                context.restore();
                context.translate(0, 16);
              }
              
              context.restore();
            }

            function drawWindow(windowType) {
              context.save();
              
              switch (windowType) {
            		case 0:
            			context.fillRect(4, 2, 8, 10);
            			break;
            		
            		case 1:
            			context.fillRect(2, 3, 5, 8);
            			context.fillRect(9, 3, 5, 8);
            			break;
            		
            		case 2:
            			context.fillRect(0, 3, 16, 8);
            			break;
            		
            		case 3:
            			context.fillRect(5, 1, 6, 14);
            			break;
            	}
              
              context.restore();
            }
            
            function drawRoof(w, roofType) {
              context.save();
              
              switch(roofType) {
            		case 0:
            			// draw nothing
            			break;
            		
            		case 1:
            			context.fillRect(8, -16, w - 16, 16);
            			break;
            		
            		case 2:
            			context.fillRect(8, -24, w - 16, 24);
            			context.fillRect((w - 32) / 2, -48, 32, 24);
            			context.fillRect((w - 8) / 2, -80, 8, 56);
            			break;
            		
            		case 3:
            			context.beginPath();
            			context.moveTo(w / 2, -80);
            			context.lineTo(w / 2 + 16, -16);
            			context.lineTo(w / 2 - 16, -16);
            			context.closePath();
            			context.fill();
            			context.fillRect((w - 64) / 2, -16, 64, 16);
            			break;
            	}
              
              context.restore();
            }
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag('lessons/animated_cityscape/stage2/challenge1.png')
            %canvas#animated_cityscape_stage2_challenge1
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Store Objects in an Array
          %p
            When storing the data used to draw three squares, it's okay to declare three
            separate variables named <code>squareA</code>, <code>squareB</code>, and
            <code>squareC</code>, one for each square. But it becomes a problem if we need
            to store the data to draw a hundred squares or if we don't know how many buildings
            we'll be drawing ahead of time, as in the Animated Cityscape Challenge.
          %p
            One way to store an arbitrary number of values in a variable is by using an array.
            An array is basically a list with an index starting at 0. Imagine a list of books
            stored in an array named <code>bookArray</code>. We can access the first book in the
            list at <code>bookArray[0]</code> and the second book at <code>bookArray[1]</code>.
            To add a new book at the end of the list, we use the array's <code>push()</code> method,
            and to find the number of books in the list, we access the array's <code>length</code>
            property.
          %p
            In this example, we update the program from the previous example to store each
            square's data in an array.
          %p
            Instead of declaring the three separate variables <code>squareA</code>,
            <code>squareB</code>, and <code>squareC</code>, we start by declaring the global
            variable <code>squareArray</code>:
          %pre
            %code
              :preserve
                var counter;
                var squareArray;
          %p
            Inside the <code>initScene()</code> method, we initialize <code>squareArray</code>
            as an empty array, <code>[]</code>. We have to initialize <code>squareArray</code>
            as an array before we can use the <code>push()</code> method to add data to the end
            of the array.
          %pre
            %code
              :preserve
                function initScene() {
                  counter = 0;
                  
                  squareArray = []; // Initialize the variable as an empty array
                  squareArray.push( {x: 200, y:  40, s: 60} ); // Add the data for the first square to the end of the array
                  squareArray.push( {x:  80, y: 120, s: 40} ); // Add the data for the second square to the end of the array
                  squareArray.push( {x: 240, y: 220, s: 80} ); // Add the data for the third square to the end of the array
                  
                  drawScene();
                }
          %p
            At this point, we have pushed the data for three squares onto the end of the array,
            and we can access the data for the first square at <code>squareArray[0]</code>, the
            data for the second square at <code>squareArray[1]</code>, and the data for the third
            square at <code>squareArray[2]</code>. By using an array, we can easily store the
            data for a hundred squares in a single variable.
          %p
            When working with objects and arrays, it's important to understand where values
            are stored and how to access them. Keep this reference in mind when working with
            the data stored in <code>squareArray</code>:
          %pre
            %code
              :preserve
                squareArray // Used to access the array containing the data for all the squares
                squareArray[0] // Used to access the data for the first square in the array
                squareArray[0].x // Used to access the x-coordinate in the data for the first square in the array
          %p
            Inside the <code>drawScene()</code> function, we could draw each square
            by passing its data into the <code>drawSquare()</code> method manually like this:
          %pre
            %code
              :preserve
                function drawScene() {
                  drawBackground();
                  
                  drawSquare(squareArray[0]);
                  drawSquare(squareArray[1]);
                  drawSquare(squareArray[2]);
                }
          %p
            But we are going to automate the process using a for loop. This way, if we add
            the data for a fourth square to the array, the <code>drawScene()</code> function
            will automatically draw it, too.
          %pre
            %code
              :preserve
                function drawScene() {
                  drawBackground();
                  
                  for (var i = 0; i < squareArray.length; i += 1) {
                    drawSquare(squareArray[i]);
                  }
                }
          %p
            Note that the for loop runs as long as <code>i < squareArray.length</code>. This
            is because, while the length of the array is 3, the last square's data is at index
            2. Remember, the index of an array starts at 0, so the last item in an array is
            always at index <code>length - 1</code>.
          %p
            Finally, we update the <code>updateScene()</code> function to use
            <code>squareArray</code> instead of <code>squareA</code>, <code>squareB</code>,
            and <code>squareC</code>.
          %pre
            %code
              :preserve
                function updateScene() {
                  counter += 1;
                  squareArray[0].x -= 5;
                  squareArray[1].x += 5;
                  squareArray[2].y -= 5;
                  drawScene();
                }
          %p
            Click on the canvas to see the scene update. Change the values stored in the
            objects to change the size and position of the squares and push another set of
            data into the array to add another square. To learn more about arrays,
            visit the
            = link_to_lesson('Arrays', :arrays, nil, class: 'reference-link', data: {slug: :arrays})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :for_loops, :objects, :arrays, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example2_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example2');
                var context = canvas.getContext('2d');
                
                var counter;
                var squareArray;
                
                initScene();
                canvas.addEventListener('click', updateScene);
                
                function initScene() {
                  counter = 0;
                  
                  squareArray = []; // Initialize the variable as an empty array
                  squareArray.push( {x: 200, y:  40, s: 60} ); // Add the data for the first square to the end of the array
                  squareArray.push( {x:  80, y: 120, s: 40} ); // Add the data for the second square to the end of the array
                  squareArray.push( {x: 240, y: 220, s: 80} ); // Add the data for the third square to the end of the array
                  
                  drawScene();
                }
                
                function drawScene() {
                  drawBackground();
                  
                  for (var i = 0; i < squareArray.length; i += 1) {
                    drawSquare(squareArray[i]);
                  }
                }
                
                function updateScene() {
                  counter += 1;
                  squareArray[0].x -= 5;
                  squareArray[1].x += 5;
                  squareArray[2].y -= 5;
                  drawScene();
                }
                
                function drawSquare(square) {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(square.x, square.y, square.s, square.s); // Use the data in the object square to draw the square
                  context.restore();
                }
                
                function drawBackground() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = '#CCCCCC';
                  context.font = '48px Arial';
                  context.fillText('Frame: ' + counter, 10, 48); // Print the number of the frame on the background
                  context.restore();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example2


  #challenge2.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 2
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/challenge1Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Update the program from Challenge 1 to store the data for each building
            in an array instead of in separate variables. Start by copying your program
            from Challenge 1 into the editor below.
          %p
            Instead of declaring the variables <code>buildingA</code>, <code>buildingB</code>,
            and <code>buildingC</code>, declare only one global variable: <code>buildingRow</code>.
          %p
            Inside the <code>initScene()</code> function, initialize <code>buildingRow</code>
            with an empty array. Then, push the data for the three buildings onto the end of the
            array using the array's <code>push()</code> method.
          %p
            Inside the <code>drawScene()</code> function, use a for loop to pass the data for
            each building into the <code>drawBuilding()</code> function along with the building
            and window colors. Remember, the data for the first building is stored in the object
            at <code>buildingRow[0]</code>, the data for the second building in the object at
            <code>buildingRow[1]</code>, and the data for the third building in the object at
            <code>buildingRow[2]</code>.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :for_loops, :objects, :arrays, :fill_rect, :fill_style]
          = render 'lessons/code_preview', stage: 1, challenge: 1, editor_id: 'animated_cityscape_stage2_challenge1_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge2_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge2');
            var context = canvas.getContext('2d');
            
            // COPY YOUR PROGRAM FROM CHALLENGE 1 HERE
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag('lessons/animated_cityscape/stage2/challenge1.png')
            %canvas#animated_cityscape_stage2_challenge2
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Initialize and Draw Building Rows Separately
          %p
            In the Basic Cityscape Challenge, we created the data for a building row and then
            drew the building row at the same time using the <code>drawBuildingRow()</code> function.
            This meant that, if we wanted to draw the building row again, we would recreate the data.
            But since the data is generated randomly, the buildings would be different each time and
            it would look like we were drawing a brand new scene instead of updating the existing scene.
          %p
            We are currently in the process of separating those two steps. The goal is to
            create the data for a building row using the <code>initBuildingRow()</code> function
            when the page first loads and then use that data to redraw the buildings using the
            <code>drawBuildingRow()</code> function when we update the scene. That way, it will
            look like the same scene changing over time.
          %p
            Since we are separating the current <code>drawBuildingRow()</code> function into two
            separate functions, you should review how the <code>drawBuildingRow()</code> function
            works. In this example, we position a building row at (0, 280) and draw it with a scale
            factor of 0.6. We use the scale factor to calculate the color of the buildings in the
            row and a while loop to create and draw just enough buildings to cover the width of the
            canvas. Each building is randomly generated using the <code>randomInteger()</code>
            function.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :while_loops, :if_statements, :fill_style, :translate, :scale, :random, :round]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example3_editor', cols: 12} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example3');
                var context = canvas.getContext('2d');
                
                drawBuildingRow(0, 280, 0.6);
                
                function drawBuildingRow(rowX, groundY, scale) {
                  context.save();
                  context.translate(rowX, groundY);
                  context.scale(scale, scale);
                  
                  var c = Math.round(153 * scale);
                  var buildingColor = 'rgb(' + c + ', ' + c + ', ' + c + ')';
                  var windowColor = 'rgb(102, 102, 102)';
                  
                  var x = 0;
                  while (x < canvas.width / scale) {
                    var units = randomInteger(4, 10);
                    var floors = randomInteger(6, 20);
                    var windowType = randomInteger(0, 3);
                    var roofType;
                    
                    if (units > 8) {
                			roofType = randomInteger(0, 1);
                		} else if (units > 6) {
                			roofType = randomInteger(0, 2);
                		} else {
                			roofType = randomInteger(0, 3);
                		}
                    
                    var w = 16 * units + 8;
                    var h = 16 * floors + 8;
                    
                    drawBuilding(x, 0, w, h, units, floors, windowType, roofType, buildingColor, windowColor);
                    x = x + w + 12;
                  }
                  
                  context.restore();
                }
                
                function drawBuilding(leftX, groundY, w, h, units, floors, windowType, roofType, buildingColor, windowColor) {
                  var x = leftX;
                  var y = groundY - h;
                  
                  context.save();
                  context.translate(x, y);
                  context.fillStyle = buildingColor;
                  context.fillRect(0, 0, w, h);
                  drawRoof(w, roofType);
                  
                  context.translate(4, 4);
                  context.fillStyle = windowColor;
                  
                  for (var i = 0; i < floors; i += 1) {
                    context.save();
                    
                    for (var j = 0; j < units; j += 1) {
                      drawWindow(windowType);
                      context.translate(16, 0);
                    }
                    
                    context.restore();
                    context.translate(0, 16);
                  }
                  
                  context.restore();
                }
    
                function drawWindow(windowType) {
                  context.save();
                  
                  switch (windowType) {
                		case 0:
                			context.fillRect(4, 2, 8, 10);
                			break;
                		
                		case 1:
                			context.fillRect(2, 3, 5, 8);
                			context.fillRect(9, 3, 5, 8);
                			break;
                		
                		case 2:
                			context.fillRect(0, 3, 16, 8);
                			break;
                		
                		case 3:
                			context.fillRect(5, 1, 6, 14);
                			break;
                	}
                  
                  context.restore();
                }
                
                function drawRoof(w, roofType) {
                  context.save();
                  
                  switch(roofType) {
                		case 0:
                			// draw nothing
                			break;
                		
                		case 1:
                			context.fillRect(8, -16, w - 16, 16);
                			break;
                		
                		case 2:
                			context.fillRect(8, -24, w - 16, 24);
                			context.fillRect((w - 32) / 2, -48, 32, 24);
                			context.fillRect((w - 8) / 2, -80, 8, 56);
                			break;
                		
                		case 3:
                			context.beginPath();
                			context.moveTo(w / 2, -80);
                			context.lineTo(w / 2 + 16, -16);
                			context.lineTo(w / 2 - 16, -16);
                			context.closePath();
                			context.fill();
                			context.fillRect((w - 64) / 2, -16, 64, 16);
                			break;
                	}
                  
                  context.restore();
                }
                
                function randomInteger(min, max) {
                  return (min + Math.floor((max - min + 1) * Math.random()));
                }

            .visual.col-xs-12.pt-2
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example3


  #challenge3.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 3
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/challenge3Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Update the program from Challenge 2 to draw a building row at a set
            position and scale. Set the building color based on the scale of the row.
            Start by copying your program from Challenge 2 into the editor below.
          %p
            Since we are going to position the row of buildings in the
            <code>drawBuildingRow()</code> function, change the <code>groundY</code>
            property for all three buildings in the row to <code>0</code>.
          %p
            Define a function named <code>drawBuildingRow()</code> which accepts three
            parameters: <code>rowX</code>, <code>groundY</code>, and <code>scale</code>.
            Use the <code>context.translate()</code> method to position the row and the
            <code>context.scale()</code> method to scale the row. Don't forget to save
            and restore the drawing state. Then, use the scale to calculate the building
            color. Look at the program in the example above to see how.
          %p
            Finally, move the for loop used to draw the buildings from the <code>drawScene()</code>
            function into the <code>drawBuildingRow()</code> function and call the
            <code>drawBuildingRow()</code> function inside the <code>drawScene()</code> function.
            Draw the row of buildings stored in the <code>buildingRow</code> array at
            (0, 280) with a scale factor of 0.6.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :for_loops, :objects, :arrays, :fill_style, :save, :translate, :scale]
          = render 'lessons/code_preview', stage: 1, challenge: 2, editor_id: 'animated_cityscape_stage2_challenge2_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge3_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge3');
            var context = canvas.getContext('2d');
            
            // COPY YOUR PROGRAM FROM CHALLENGE 2 HERE
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag('lessons/animated_cityscape/stage2/challenge3.png')
            %canvas#animated_cityscape_stage2_challenge3
          .alert


  #challenge4.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 4
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/challenge4Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            To turn the sky along the horizon red as the sun sets, we need to add a
            third color stop between positions <code>0</code> and <code>1</code>. The
            third color stop will confine the red color to a narrow band.
          %p
            Start by setting <code>horizonY</code>, the y-coordinate of the horizon,
            and copying the definitions for the <code>rgbColor()</code> and <code>drawSky()</code>
            functions from Challenge 3.
          %p
            Inside the <code>drawSky()</code> function, declare the variables <code>pMiddle</code>,
            <code>rMiddle</code>, <code>gMiddle</code>, and <code>bMiddle</code> for the middle color
            stop. We are using <code>pMiddle</code> to set the position of the color stop. By starting
            at position <code>1</code> and moving down to position <code>0</code>, it will confine the
            red color to a narrower and narrower band until it disappears completely.
          %p
            If <code>time < 5</code> or <code>time > 7</code>, set <code>pMiddle</code> to -1.
          %p
            Why are we setting <code>pMiddle</code> to -1? Before 5:00 pm and after 7:00 pm, we only
            need to add color stops at positions <code>0</code> and <code>1</code>; we aren't adding
            a third color stop at position <code>pMiddle</code>. By setting <code>pMiddle</code> to -1,
            we are letting ourselves know not to add the third color stop later on.
          %p
            In the code block for the else clause, change the calculations for the color at
            position <code>0</code> and add the calculations for the color at position <code>pMiddle</code>.
            The calculations for the color at position <code>1</code> stay the same.
          %ul
            %li
              <code>r0</code>: 255
            %li
              <code>g0</code>: 255 &rarr; 0
            %li
              <code>b0</code>: 255 &rarr; 0
            %li
              <code>pMiddle</code>: 1 &rarr; 0
            %li
              <code>rMiddle</code>: 102
            %li
              <code>gMiddle</code>: 153 &rarr; 102
            %li
              <code>bMiddle</code>: 255 &rarr; 102
          %p
            This changes the color of the sky at position <code>0</code> from white to red
            and the color of the sky at position <code>1</code> from blue to dark gray. We
            use the middle color stop at position <code>pMiddle</code> to make the red band
            at the horizon narrower. The color of the sky at the middle color stop changes
            from blue to gray, but it also moves closer to the horizon as <code>pMiddle</code>
            changes from 1 to 0.
          %p
            After creating the linear gradient and adding color stops at positions <code>0</code>
            and <code>1</code>, add the middle color stop only if <code>pMiddle >= 0</code>. If
            <code>pMiddle</code> is -1, the program will skip this step and the middle color stop
            won't be added.
          %pre
            %code
              :preserve
                if (pMiddle >= 0) {
                  gradient.addColorStop(pMiddle, rgbColor(rMiddle, gMiddle, bMiddle));
                }
          %p
            The program should now draw slices of the sky as it gets darker and redder along
            the horizon at 5:00, 5:30, 6:00, 6:30, and 7:00 pm. If you need help with if statements
            and linear gradients, visit the
            = link_to_lesson('If Statements', :if_statements, nil, class: 'reference-link', data: {slug: :if_statements})
            and
            = link_to_lesson('createLinearGradient()', :create_linear_gradient, nil, class: 'reference-link', data: {slug: :create_linear_gradient})
            lessons.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :create_linear_gradient]
          = render 'lessons/code_preview', stage: 1, challenge: 3, editor_id: 'animated_cityscape_stage2_challenge3_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge4_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge4');
            var context = canvas.getContext('2d');

            // COPY YOUR PROGRAM FROM CHALLENGE 3 HERE

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage2_challenge4
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Mouse Click
          %p
            At this point, we can draw the sky and ground at any time of day by manually
            setting the <code>time</code> variable. The next step is writing a program
            which updates the <code>time</code> variable and redraws the scene automatically.
          %p
            A JavaScript program is triggered by events. So far, we've done all of our
            drawing immediately when the page first loads. But we can also tell our program
            to listen for events and run specific functions when those events occur.
          %p
            In this example, we run the following code when the page loads:
          %pre
            %code
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
          %p
            We start by storing a reference to the canvas and the canvas's context in the
            variables <code>canvas</code> and <code>context</code>. Then, we declare the global
            variables <code>squareX</code> and <code>squareY</code>. We need to declare these
            variables globally so all of our functions can use them and the values stored in them
            are persistent and aren't deleted once a function ends. To learn more about variables
            and scope, visit the
            = link_to_lesson('Variables', :variables, nil, class: 'reference-link', data: {slug: :variables})
            lesson. Finally, we call the <code>initScene()</code> function and use the
            <code>addEventListener()</code> method to register an event listener on the canvas
            object. Note: "init" is short for initialize.
          %p
            The <code>initScene()</code> function sets the initial values of <code>squareX</code>
            and <code>squareY</code> and calls the <code>drawScene()</code> function:
          %pre
            %code
              :preserve
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
          %p
            The <code>drawScene()</code> function draws a square filled with the color
            <code>'RoyalBlue'</code> at the coordinates (<code>squareX</code>, <code>squareY</code>):
          %pre
            %code
              :preserve
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
          %p
            By registering to listen for <code>'click'</code> events, the program will
            automatically call the <code>updateScene()</code> function whenever a mouse
            click is detected on the canvas. Note: Because we are passing the
            <code>updateScene()</code> function into the <code>addEventListener()</code>
            method as a variable, we don't include parentheses after the function name. To learn
            more about passing functions as variables and registering event listeners, visit the
            = link_to_lesson('Functions', :functions, nil, class: 'reference-link', data: {slug: :functions})
            and
            = link_to_lesson('Event Listeners', :event_listeners, nil, class: 'reference-link', data: {slug: :event_listeners})
            lessons.
          %p
            The <code>updateScene()</code> method adds 30 to <code>squareX</code> and 20
            to <code>squareY</code> before calling the <code>drawScene()</code> function
            and drawing another square:
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 30; // This is a shorter way of writing squareX = squareX + 30
                  squareY += 20; // This is a shorter way of writing squareY = squareY + 20
                  
                  drawScene();
                }
          %p
            Now we can automatically update the drawing on the canvas simply by clicking
            on it. Note that the new scene is drawn on top of the existing scene. If we
            wanted to redraw the square and make it look like the square is moving, we'd
            have to clear the canvas first.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example4_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 30; // This is a shorter way of writing squareX = squareX + 30
                  squareY += 20; // This is a shorter way of writing squareY = squareY + 20
                  
                  drawScene();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example4


  #challenge5.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 5
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage2/challenge5Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like at 6:12 pm
          %p
            Write a program that increases the <code>time</code> and redraws the scene
            when a mouse click is detected on the canvas.
          %p
            Start by copying the definitions for the <code>drawSky()</code>,
            <code>drawGround()</code>, and <code>rgbColor()</code> functions from Challenges 2 and 4.
          %p
            Inside the <code>initScene()</code> function, set <code>time</code> to 5,
            set <code>horizonY</code> so the horizon is 100 pixels above the bottom of
            the canvas, and then call the <code>drawScene()</code> function.
          %p
            Inside the <code>drawScene()</code> function, draw the sky and ground. Then,
            call the <code>drawTime()</code> function to automatically draw the time in the
            bottom left corner of the canvas.
          %p
            Inside the <code>updateScene()</code> function, increase the <code>time</code>
            by 0.2 if <code>time < 7</code>, else reset the <code>time</code> back to 5.
            Then, call the <code>drawScene()</code> function to draw a new scene on top of
            the current one.
          %p
            Press "Run" and click on the canvas enough times to see the sky and ground change
            color between 5:00 and 7:00 pm. Once you feel satisfied that the scene is updating
            and drawing correctly, mark the challenge as complete by selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners]
          = render 'lessons/code_preview', stage: 1, challenge: 4, editor_id: 'animated_cityscape_stage2_challenge4_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge5_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge5');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY;
            
            initScene();
            canvas.addEventListener('click', updateScene);
            
            function initScene() {
              
              // Set the time to 5
              // Set horizonY so the horizon is 100 pixels above the bottom of the canvas
              // Draw the scene
              
            }
            
            function drawScene() {
              
              // Draw the sky
              // Draw the ground
              
              drawTime(); // Draw the time in the bottom left corner
              
            }
            
            function updateScene() {
              
              // If time < 7, increase the time by 0.2, else reset the time back to 5
              // Draw the scene
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawGround() {
              
              // Copy the function definition from Challenge 2
              
            }
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawTime() {
              var t;
              var h = Math.floor(time);
              var m = Math.round(60 * (time - h));
              
              if (m >= 10) {
                t = h + ':' + m;
              } else {
                t = h + ':0' + m;
              }
              
              context.save();
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.fillText(t, 10, canvas.height - 10);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage2_challenge5
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Timer
          %p
            Instead of using a mouse click to update the time and redraw the scene,
            we are going to use a timer.
          %p
            In this example, we set up a timer to update the scene from the previous
            example. We start by declaring the global variable <code>timer</code>. Then,
            instead of adding an event listener to the canvas object to detect mouse
            clicks, we use the <code>setInterval()</code> method to create a timer that will
            automatically call the <code>updateScene()</code> function every 25 milliseconds.
            We store a reference to the timer in the variable <code>timer</code>.
          %pre
            %code
              :preserve
                var timer;
                
                timer = setInterval(updateScene, 25); // Call the updateScene() function every 25 milliseconds
          %p
            Again, because we are passing the <code>updateScene()</code> function into
            the <code>setInterval()</code> method as a variable, we don't include
            parentheses at the end of the function name. The number <code>25</code> tells
            the timer how long to wait before calling the <code>updateScene()</code>
            function again. The <code>setInterval()</code> method measures time in
            milliseconds and there are 1000 milliseconds in one second. So, if the timer
            calls the <code>updateScene()</code> function every 25 milliseconds, it will
            update the scene 40 times per second (1000 &divide; 25 = 40).
          %p
            Inside the <code>updateScene()</code> function, we increase <code>squareX</code>
            and <code>squareY</code> by 3 and 2, instead of 30 and 20, so the square doesn't
            move as far in each update. Then, if <code>squareX > canvas.width</code>, which
            means the latest square is positioned past the right edge of the canvas, we cancel
            the timer and stop updating the scene by passing the reference stored in the
            <code>timer</code> variable into the <code>clearInterval()</code> method.
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    clearInterval(timer); // Cancel the timer and stop updating the scene
                  }
                }
          %p
            Finally, inside the <code>drawScene()</code> function, before drawing the
            square, we draw a rectangle filled with the color <code>'Cornsilk'</code>
            covering the entire canvas. This will cover the previous scene, so now it
            looks like one square is moving instead of a new square being drawn each time.
          %pre
            %code
              :preserve
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
          %p
            Press "Run" to reload the page and start the animation.
          %p
            See what happens if you don't draw a rectangle over the previous scene or if
            you change how far the square moves or the time interval between updates. Note:
            if you try to update the scene too quickly, the program won't be able to keep
            up and the animation may stutter. To learn more setting timers, visit the
            = link_to_lesson('setInterval()', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :fill_rect, :fill_style, :set_interval]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example5_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example5');
                var context = canvas.getContext('2d');
                
                var timer;
                var squareX, squareY;
                
                initScene();
                timer = setInterval(updateScene, 25);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    clearInterval(timer); // Cancel the timer and stop updating the scene
                  }
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example5


  #challenge6.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 6
          %p
            Copy the program from Challenge 5.
          %p
            Then, change the program so that, instead of listening for mouse clicks to
            update the scene, a timer automatically calls the <code>updateScene()</code>
            function every 50 milliseconds.
          %p
            Inside the <code>updateScene()</code> function, increase the time by 0.05
            and, instead of resetting the time back to 5, cancel the timer and stop updating
            the scene if <code>time > 7</code>.
          %p
            Press "Run" and watch the sky and ground change color between 5:00 and 7:00 pm.
            If you need to slow the animation down to get a better look, increase the time
            interval passed into the <code>setInterval()</code> method. Once you feel satisfied
            that the scene is updating and drawing correctly, mark the challenge as complete by
            selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:variables, :functions, :set_interval]
          = render 'lessons/code_preview', stage: 1, challenge: 5, editor_id: 'animated_cityscape_stage2_challenge5_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge6_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge6');
            var context = canvas.getContext('2d');

            var time;
            var horizonY;
            
            initScene();
            canvas.addEventListener('click', updateScene);
            
            function initScene() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawScene() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function updateScene() {
              
              // Copy the function definition from Challenge 5
              
              // Increase the time by 0.05
              // If time >= 7, cancel the timer and stop updating the scene
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawGround() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawTime() {
              var t;
              var h = Math.floor(time);
              var m = Math.round(60 * (time - h));
              
              if (m >= 10) {
                t = h + ':' + m;
              } else {
                t = h + ':0' + m;
              }
              
              context.save();
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.fillText(t, 10, canvas.height - 10);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage2_challenge6
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Play and Pause the Scene
          %p
            In this example, we add event listeners to the previous example's program
            to play and pause the scene.
          %p
            We can register our program to listen for more than mouse click events. On
            a web page, only one HTML element can have the focus at a time. The focus
            determines which element is actively receiving keyboard events. On this page
            alone there are thirteen editors. It would get kind of crazy if you were typing
            into more than one editor at a time.
          %p
            Note: A canvas element does not normally receive the focus. We have enabled
            each canvas to receive the focus by setting its <code>tabindex</code> attribute.
            That's not something you need to know about until you start creating the HTML
            for your own web pages.
          %p
            Because we have enabled each canvas to receive the focus, clicking on a
            canvas selects it and triggers a <code>'focus'</code> event. Clicking on a
            different part of the page deselects it and triggers a <code>'blur'</code>
            event. We start by adding event listeners to play the scene when the canvas
            receives a <code>'focus'</code> event and pause the scene when the canvas
            receives a <code>'blur'</code> event.
          %pre
            %code
              :preserve
                canvas.addEventListener('focus', playScene);
                canvas.addEventListener('blur', pauseScene);
          %p
            Instead of starting the timer when the page first loads, we start the timer
            inside the <code>playScene()</code> function. We also check the position of
            the last square before starting the timer. If the last square is off the canvas,
            we reset it's position.
          %pre
            %code
              :preserve
                function playScene() {
                  if (squareX > canvas.width) {
                    squareX = 10;
                    squareY = 10; // Reset the square's position
                  }
                  
                  timer = setInterval(updateScene, 25);
                }
          %p
            Inside the <code>pauseScene()</code> function, we cancel the timer and
            draw the text string <code>'Click to Play'</code> in the center of the
            canvas so the user knows how to start the animation.
          %pre
            %code
              :preserve
                function pauseScene() {
                  clearInterval(timer);
                  
                  context.save();
                  context.fillStyle = 'Black';
                  context.font = '16px Arial';
                  context.textAlign = 'center';
                  context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
                  context.restore();
                }
          %p
            We also call the <code>pauseScene()</code> function when the page first loads
            so the <code>'Click to Play'</code> text string is drawn right away.
          %p
            Then, inside the <code>updateScene()</code> function, instead of canceling
            the timer if <code>squareX > canvas.width</code>, we use the <code>blur()</code>
            method to blur the canvas. When the canvas loses the focus, it receives a
            <code>blur</code> event and the <code>pauseScene()</code> function is called.
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    canvas.blur(); // Remove the focus from the canvas
                  }
                }
          %p
            Click on the canvas to start the animation. The animation will continue
            running until you click on a different part of the page or until the latest
            square is positioned past the right edge of the canvas. If you restart the
            animation and the latest square was positioned past the right edge of the
            canvas, <code>squareX</code> and <code>squareY</code> are reset and the animation
            starts again from the beginning.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners, :fill_rect, :fill_style, :set_interval]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_example6_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage2_example6');
                var context = canvas.getContext('2d');
                
                var timer;
                var squareX, squareY;
                
                initScene();
                pauseScene();
                canvas.addEventListener('focus', playScene);
                canvas.addEventListener('blur', pauseScene);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    canvas.blur(); // Remove the focus from the canvas
                  }
                }
                
                function playScene() {
                  if (squareX > canvas.width) {
                    squareX = 10;
                    squareY = 10; // Reset the square's position
                  }
                  
                  timer = setInterval(updateScene, 25);
                }
                
                function pauseScene() {
                  clearInterval(timer);
                  
                  context.save();
                  context.fillStyle = 'Black';
                  context.font = '16px Arial';
                  context.textAlign = 'center';
                  context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
                  context.restore();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage2_example6


  #challenge7.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 7
          %p
            Copy the program from Challenge 6.
          %p
            Then, change the program so the scene is initially paused and the time set
            to 2. Play the scene when the canvas receives the focus and continue playing
            the scene until the canvas loses the focus or until <code>time > 12</code>. If
            the canvas receives the focus and the time is already greater than 12, reset
            the time back to 2 and replay the scene from the beginning.
          %p
            Press "Run" and click on the canvas to start playing the scene. Once you feel
            satisfied that the scene is playing and pausing correctly, mark the challenge
            as complete by selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:variables, :functions, :event_listeners, :set_interval]
          = render 'lessons/code_preview', stage: 1, challenge: 6, editor_id: 'animated_cityscape_stage2_challenge6_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage2_challenge7_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage2_challenge7');
            var context = canvas.getContext('2d');

            // Copy the program from Challenge 6 here
            
            function playScene() {
              
            }
            
            function pauseScene() {
              
              // Cancel the timer
              
              context.save();
              context.fillStyle = 'rgba(0, 0, 0, 0.2)';
              context.fillRect(canvas.width / 2 - 55, canvas.height / 2 - 18, 110, 24);
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.textAlign = 'center';
              context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage2_challenge7
          .alert
