#animated_cityscape_stage1.page
  %h1
    Stage 1
  .description.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Overview
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/overviewVisual1.png', class: 'img-fluid')
          %p
            In the Basic Cityscape Challenge, we drew three rows of randomly-generated
            buildings, creating a 3D effect by drawing the buildings in the back smaller
            and darker.
          %p
            In the first stage of the Animated Cityscape Challenge, we draw the
            sky behind the buildings, changing the color of the sky to simulate nightfall.


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Review the Basic Cityscape Challenge
          %p
            Because we are extending the program for the Basic Cityscape Challenge to
            animate the drawing, it's important to understand how that program works.
          %p
            We start by drawing a gray rectangle (color <code>'#CCCCCC'</code>) for
            the ground beneath the buildings. Then, we use the <code>drawBuildingRow()</code>
            function to draw three rows of buildings.
          %pre
            %code
              :preserve
                context.fillStyle = '#CCCCCC';
                context.fillRect(0, 220, canvas.width, canvas.height - 220);
                
                drawBuildingRow(0, 280, 0.6);
                drawBuildingRow(0, 300, 0.8);
                drawBuildingRow(0, 320, 1.0);
          %p
            The first row of buildings is positioned at (0, 280) and drawn at 60% scale,
            the second row of buildings is positioned at (0, 300) and drawn at 80% scale, and
            the third row of buildings is positioned at (0, 320) and drawn at 100% scale.
          %p
            Inside the <code>drawBuildingRow()</code> function, we use the <code>scale</code>
            parameter to calculate the color of the buildings in the row. The smaller the scale,
            the darker the buildings. Then, we use a while loop to draw buildings the width of the
            canvas. To draw a building, we randomly generate the number of office units per floor,
            the number of floors, the type of windows, and the type of roof for the building and
            pass those values into the <code>drawBuilding()</code> function.
          %p
            The <code>randomInteger()</code> function is used to generate random integers,
            switch statements inside the <code>drawWindow()</code> and <code>drawRoof()</code>
            functions are used to draw the four different types of windows and roofs, and
            nested for loops are used to draw windows in each office unit in each building.
          %p
            Please make sure you fully understand the program in the example below before continuing on in
            this challenge. If you need help, visit the Basic Cityscape Challenge and its relevant lessons.
          = render 'lessons/relevant', relevant: [:variables, :functions, :for_loops, :switch_statements, :while_loops, :fill_rect, :fill_style, :random, :scale]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example1_editor', cols: 12} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example1');
                var context = canvas.getContext('2d');
                
                context.save();
                context.fillStyle = '#CCCCCC';
                context.fillRect(0, 220, canvas.width, canvas.height - 220);
                
                drawBuildingRow(0, 280, 0.6);
                drawBuildingRow(0, 300, 0.8);
                drawBuildingRow(0, 320, 1.0);
                
                context.restore();
                
                function drawBuildingRow(rowX, groundY, scale) {
                  context.save();
                  context.translate(rowX, groundY);
                  context.scale(scale, scale);
                  
                  var c = Math.round(153 * scale);
                  var buildingColor = 'rgb(' + c + ', ' + c + ', ' + c + ')';
                  var windowColor = 'rgb(102, 102, 102)';
                  
                  var x = 0;
                  while (x < canvas.width / scale) {
                    var units = randomInteger(4, 10);
                    var floors = randomInteger(6, 20);
                    var windowType = randomInteger(0, 3);
                    var roofType;
                    
                    if (units > 8) {
                			roofType = randomInteger(0, 1);
                		} else if (units > 6) {
                			roofType = randomInteger(0, 2);
                		} else {
                			roofType = randomInteger(0, 3);
                		}
                    
                    var w = 16 * units + 8;
                    var h = 16 * floors + 8;
                    
                    drawBuilding(x, 0, w, h, units, floors, windowType, roofType, buildingColor, windowColor);
                    x = x + w + 12;
                  }
                  
                  context.restore();
                }
                
                function drawBuilding(leftX, groundY, w, h, units, floors, windowType, roofType, buildingColor, windowColor) {
                  var x = leftX;
                  var y = groundY - h;
                  
                  context.save();
                  context.translate(x, y);
                  context.fillStyle = buildingColor;
                  context.fillRect(0, 0, w, h);
                  drawRoof(w, roofType);
                  
                  context.translate(4, 4);
                  context.fillStyle = windowColor;
                  
                  for (var i = 0; i < floors; i = i + 1) {
                    context.save();
                    
                    for (var j = 0; j < units; j = j + 1) {
                      drawWindow(windowType);
                      context.translate(16, 0);
                    }
                    
                    context.restore();
                    context.translate(0, 16);
                  }
                  
                  context.restore();
                }
    
                function drawWindow(windowType) {
                  context.save();
                  
                  switch (windowType) {
                		case 0:
                			context.fillRect(4, 2, 8, 10);
                			break;
                		
                		case 1:
                			context.fillRect(2, 3, 5, 8);
                			context.fillRect(9, 3, 5, 8);
                			break;
                		
                		case 2:
                			context.fillRect(0, 3, 16, 8);
                			break;
                		
                		case 3:
                			context.fillRect(5, 1, 6, 14);
                			break;
                	}
                  
                  context.restore();
                }
                
                function drawRoof(w, roofType) {
                  context.save();
                  
                  switch(roofType) {
                		case 0:
                			// draw nothing
                			break;
                		
                		case 1:
                			context.fillRect(8, -16, w - 16, 16);
                			break;
                		
                		case 2:
                			context.fillRect(8, -24, w - 16, 24);
                			context.fillRect((w - 32) / 2, -48, 32, 24);
                			context.fillRect((w - 8) / 2, -80, 8, 56);
                			break;
                		
                		case 3:
                			context.beginPath();
                			context.moveTo(w / 2, -80);
                			context.lineTo(w / 2 + 16, -16);
                			context.lineTo(w / 2 - 16, -16);
                			context.closePath();
                			context.fill();
                			context.fillRect((w - 64) / 2, -16, 64, 16);
                			break;
                	}
                  
                  context.restore();
                }
                
                function randomInteger(min, max) {
                  return (min + Math.floor((max - min + 1) * Math.random()));
                }

            .visual.col-xs-12.pt-2
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example1


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Draw the Sky Behind the Buildings
          %p
            The sky behind the buildings is not a solid color. During the day, the sky is
            white along the horizon and bluer higher up. At night, the sky is gray along the
            horizon and darker higher up. And as the sun sets, the sky along the horizon
            turns red.
          %p
            To draw the sky, we use a linear gradient. A linear gradient smoothly transitions
            from one color to another, such as white to blue or gray to dark gray. In
            this example, we create a linear gradient using the <code>createLinearGradient()</code>
            method and assign it to a variable named <code>gradient</code>:
          %pre
            %code
              :preserve
                var gradient = context.createLinearGradient(40, 0, 360, 0);
          %p
            We create a linear gradient by passing the <code>createLinearGradient()</code> method
            the coordinates for the gradient's start position and end position. Because the two points,
            (40, 0) and (360, 0), form a horizontal line, the linear gradient is horizontal. It starts
            at x = 40 and ends at x = 360. The y-coordinates of the two points in a horizontal linear
            gradient don't make a difference as long as they are the same.
          %p
            The next step is setting the colors in the gradient:
          %pre
            %code
              :preserve
                gradient.addColorStop(0, 'Red');
                gradient.addColorStop(0.6, 'Blue');
                gradient.addColorStop(1, 'Black');
          %p
            This sets the color in the gradient at x = 40 (position <code>0</code>) to <code>'Red'</code>
            and the color at x = 360 (position <code>1</code>) to <code>'Black'</code>. We also set
            the color at x = 232 (position <code>0.6</code>) to <code>'Blue'</code>. This position is 60%
            of the way from position <code>0</code> to position <code>1</code>.
          %p
            Finally, we assign the linear gradient stored in the variable <code>gradient</code> to the
            <code>context.fillStyle</code> property and use the <code>context.fillRect()</code> method to
            draw a filled rectangle.
          %pre
            %code
              :preserve
                context.fillStyle = gradient;
                context.fillRect(40, 40, 320, 240);
          %p
            Between position <code>0</code> and position <code>0.6</code>, the color filling the rectangle
            changes from <code>'Red'</code> to <code>'Blue'</code>. Between position <code>0.6</code>
            and position <code>1</code>, the color changes from <code>'Blue'</code> to <code>'Black'</code>.
          %p
            Change the colors in the gradient, change the position of the middle color stop, or add another
            color stop with a position between <code>0</code> and <code>1</code> to see what happens. To learn more
            about linear gradients, visit the
            = link_to_lesson('createLinearGradient()', :create_linear_gradient, nil, class: 'reference-link', data: {slug: :create_linear_gradient})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :fill_rect, :fill_style, :create_linear_gradient]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example2_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example2');
                var context = canvas.getContext('2d');
                
                var gradient = context.createLinearGradient(40, 0, 360, 0);

                gradient.addColorStop(0, 'Red');
                gradient.addColorStop(0.6, 'Blue');
                gradient.addColorStop(1, 'Black');

                context.fillStyle = gradient;
                context.fillRect(40, 40, 320, 240);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example2


  #challenge1.challenge.row.py-3
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 1
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge1Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Declare a variable named <code>horizonY</code> and assign it the value
            <code>canvas.height - 100</code>. This sets the y-coordinate of the horizon
            100 pixels above the bottom of the canvas.
          %p
            Define a function named <code>drawSky()</code>. Inside the function, create
            a vertical linear gradient so position <code>0</code> is at the horizon and
            position <code>1</code> is 300 pixels above the horizon. Note that the y-coordinate
            of position <code>1</code> may be negative and not visible on the canvas.
          %p
            Set the color in the gradient at position <code>0</code> to <code>'rgb(255, 85, 85)'</code>,
            the color at position <code>0.3</code> to <code>'rgb(102, 119, 153)'</code>, and the color at
            position <code>1</code> to <code>'rgb(68, 85, 119)'</code>.
          %p
            Fill a rectangle with the gradient positioned at (0, 0) going down to the horizon and
            across the width of the canvas.
          %p
            Since the <code>drawSky()</code> function is setting the <code>context.fillStyle</code>
            property, make sure to save and restore the drawing state at the start and end of the function.
          %p
            Then, use the <code>drawSky()</code> function to draw the sky. This is approximately how the
            sky will look at 6:20 pm once the cityscape is animated.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :fill_rect, :fill_style, :save, :create_linear_gradient]

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge1_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge1');
            var context = canvas.getContext('2d');
            
            // DECLARE AND INITIALIZE THE horizonY VARIABLE HERE
            
            // CALL THE drawSky() FUNCTION HERE TO DRAW THE SKY
            
            // DEFINE THE drawSky() FUNCTION HERE
            // INSIDE THE drawSky() FUNCTION, CREATE A VERTICAL LINEAR GRADIENT
            // FROM THE HORIZON TO A POINT 300 PIXELS ABOVE THE HORIZON.
            // SET THE COLORS IN THE GRADIENT.
            // USE THE GRADIENT TO FILL A RECTANGLE POSITIONED AT (0, 0) THAT GOES
            // DOWN TO THE HORIZON AND ACROSS THE WIDTH OF THE CANVAS.
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge1
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Change Ground and Sky Colors Over Time
          %p
            The colors used to draw the sky in Challenge 1 are the colors of the sky at
            6:20 pm in the animated cityscape. However, the colors of the sky are slightly
            different at 6:10 pm and 6:30 pm. Because we change the color of the ground and
            sky forty times between 5:00 pm and 7:00 pm, we need an easy way to calculate
            these colors automatically.
          %p
            In this example, we use two for loops to draw two rows of rectangles. The first
            for loop uses the variable <code>i</code> as its counter. Inside the for loop,
            we use an if statement to calculate the height of the rectangle depending on the
            value of the counter. Note how the height of the rectangle starts at 40, climbs
            steadily to 100, and then levels out again. We want the ground and sky colors to
            change in the same way as the sun sets.
          %pre
            %code
              :preserve
                if (i < 6) {
                  h = 40;
                } else if (i > 15) {
                  h = 100;
                } else {
                  h = 40 + 60 * (i - 6) / 9;
                }
          %p
            When the program reaches the if statement, it checks the first condition. If
            <code>i < 6</code>, the height of the rectangle is set to 40. If the first condition
            is false, then the program checks the second condition. If <code>i > 15</code>, the
            height of the rectangle is set to 100. If both conditions are false, then the program
            runs the code block in the else clause and the height of the rectangle is set to the
            value of <code>40 + 60 * (i - 6) / 9</code>.
          %p
            The expression <code>40 + 60 * (i - 6) / 9</code> is designed to increase from 40 to
            100 as <code>i</code> increases from 6 to 15. Note that <code>(6 - 6) / 9</code> = 0
            when <code>i</code> is 6 and <code>(15 - 6) / 9</code> = 1 when <code>i</code> is 15.
          %p
            In the second for loop, we design the expression inside the if statement so the height
            of the rectangle decreases from 160 to 50 as <code>j</code> increases from 3 to 10. Can
            you update the second for loop so the height of the rectangle decreases from 150 to 90
            as <code>j</code> increases from 8 to 13?
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :if_statements, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example3_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example3');
                var context = canvas.getContext('2d');
                
                var x, y, h;
                context.fillStyle = 'Crimson';
                
                for (var i = 0; i < 20; i = i + 1) {
                  if (i < 6) {
                    h = 40;
                  } else if (i > 15) {
                    h = 100;
                  } else {
                    h = 40 + 60 * (i - 6) / 9;
                  }
                  
                  x = 20 * i;
                  y = 120 - h;
                  
                  context.fillRect(x, y, 18, h);
                }
                
                context.fillStyle = 'BlueViolet';
                
                for (var j = 0; j < 20; j = j + 1) {
                  if (j < 3) {
                    h = 160;
                  } else if (j > 10) {
                    h = 50;
                  } else {
                    h = 160 - 110 * (j - 3) / 7;
                  }
                  
                  x = 20 * j;
                  y = 300 - h;
                  
                  context.fillRect(x, y, 18, h);
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example3


  #challenge2.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 2
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge2Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            The <code>drawGround()</code> function will draw the rectangle for the
            ground using darker shades of gray as the time increases from 5:00 pm to
            7:00 pm. Because we are calculating RGB values based on the time, we
            start by defining the <code>rgbColor()</code> function to make it easy to
            combine RGB values into a text string in 'rgb()' notation.
          %p
            The <code>rgbColor()</code> function has three parameters: <code>r</code>,
            <code>g</code>, and <code>b</code>. Round the values stored in the three parameters
            using the <code>Math.round()</code> function and combine them into a text
            string in 'rgb()' notation using the <code>+</code> operator. Then, return the text
            string from the function using a return statement.
          %p
            If you need help, examine the <code>drawBuildingRow()</code> and <code>randomInteger()</code>
            functions in the Basic Cityscape Challenge program at the top of the page to see how we
            combined values into a text string to describe a row's building color and how we returned randomly
            generated integers from a function, or visit the
            = link_to_lesson('fillStyle', :fillStyle, nil, class: 'reference-link', data: {slug: :fillStyle})
            and
            = link_to_lesson('Functions', :functions, nil, class: 'reference-link', data: {slug: :functions})
            lessons.
          %p
            Inside the <code>drawGround()</code> function, declare the variable <code>c</code>. We
            can use this one variable to store the red, green, and blue values of the ground's color
            because all three values are the same. If <code>time < 5</code>, set <code>c = 204</code>.
            If <code>time > 7</code>, set <code>c = 102</code>. If <code>time</code> is between 5 and 7,
            create an expression so <code>c</code> decreases from 204 to 102 as <code>time</code> increases
            from 5 to 7. Pass the value of <code>c</code> into the <code>rgbColor()</code> function and
            assign the color returned from the function to the <code>context.fillStyle</code> property.
            Remember, <code>c</code> is the value of the red, green, and blue values of the color.
          %p
            Then, use the <code>context.fillRect()</code> method to draw a rectangle from (0, <code>horizonY</code>)
            to the bottom of the canvas and the width of the canvas. Make sure to save and restore the drawing
            state since the <code>drawGround()</code> function is setting the <code>context.fillStyle</code> property.
          %p
            Finally, set the value of <code>horizonY</code> so the y-coordinate of the horizon is 100 pixels
            above the bottom of the canvas. The program should now draw slices of the ground as it gets darker
            at 5:00, 5:30, 6:00, 6:30, and 7:00 pm.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :round]
          = render 'lessons/code_preview', stage: 1, challenge: 1, editor_id: 'animated_cityscape_stage1_challenge1_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge2_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge2');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawGround(); // Draw the ground at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawGround(); // Draw the ground at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawGround(); // Draw the ground at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawGround(); // Draw the ground at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawGround(); // Draw the ground at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Create and return a text string in rgb() notation after rounding the values stored in r, g, and b
              
            }
            
            function drawGround() {
              
              // Declare the variable c
              // Use an if statement to calculate the value of c
              // Use the rgbColor() function to get the color of the ground and assign it to the fillStyle
              // Draw a filled rectangle from (0, horizonY) to the bottom of the canvas and the width of the canvas
              
            }
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge2
          .alert


  #challenge3.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 3
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge3Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Now we are going to update the <code>drawSky()</code> function so the
            gradient used to fill the sky also changes depending on the time of day.
            First, we will make the sky change from blue to dark gray. We will add
            the red horizon later.
          %p
            Inside the <code>drawSky()</code> function, start by declaring six
            variables. To keep the function compact, we can declare multiple variables
            on each line. Just separate the variables with commas and make sure to end
            each line with a semicolon.
          %pre
            %code
              :preserve
                var r0, g0, b0;
                var r1, g1, b1;
          %p
            The variables <code>r0</code>, <code>g0</code>, and <code>b0</code> are the
            RGB values of the color at position <code>0</code> in the gradient. The variables
            <code>r1</code>, <code>g1</code>, and <code>b1</code> are the RGB values of the
            color at position <code>1</code>.
          %p
            If <code>time < 5</code>, set <code>r0</code>, <code>g0</code>, and <code>b0</code>
            to 255; and set <code>r1</code> to 102, <code>g1</code> to 153, and <code>b1</code>
            to 255. And just as we can declare multiple variables on one line, we can also assign
            multiple variables on one line.
          %pre
            %code
              :preserve
                r0 = 255, g0 = 255, b0 = 255; // The sky is white at position 0
                r1 = 102, g1 = 153, b1 = 255; // The sky is blue at position 1
          %p
            If <code>time > 7</code>, set <code>r0</code>, <code>g0</code>, and <code>b0</code> to 102;
            and set <code>r1</code>, <code>g1</code>, and <code>b1</code> to 51.
          %pre
            %code
              :preserve
                r0 = 102, g0 = 102, b0 = 102; // The sky is gray at position 0
                r1 = 51, g1 = 51, b1 = 51; // The sky is dark gray at position 1
          %p
            Finally, if <code>time < 5</code> and <code>time > 7</code> are both false, create
            expressions to calculate the RGB values of the colors at both positions as <code>time</code>
            increases from 5 to 7. This changes the color of the sky at position <code>0</code> from white
            to gray and the color of the sky at position <code>1</code> from blue to dark gray.
          %ul
            %li
              <code>r0</code>: 255 &rarr; 102
            %li
              <code>g0</code>: 255 &rarr; 102
            %li
              <code>b0</code>: 255 &rarr; 102
            %li
              <code>r1</code>: 102 &rarr; 51
            %li
              <code>g1</code>: 153 &rarr; 51
            %li
              <code>b1</code>: 255 &rarr; 51
          %p
            Now, just as in Challenge 1, create a vertical linear gradient so position
            <code>0</code> is at the horizon and position <code>1</code> is 300 pixels above the horizon.
          %p
            Instead of hardcoding three color stops, add color stops at positions <code>0</code>
            and <code>1</code> and use the RGB values stored in the six variables to set the colors
            using the <code>rgbColor()</code> function.
          %p
            Fill a rectangle with the gradient positioned at (0, 0) going down to the horizon and
            across the width of the canvas.
          %p
            Then, set the value of <code>horizonY</code> so the y-coordinate of the horizon is 100 pixels
            above the bottom of the canvas. The program should now draw slices of the sky as it gets darker
            at 5:00, 5:30, 6:00, 6:30, and 7:00 pm.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :create_linear_gradient]
          = render 'lessons/code_preview', stage: 1, challenge: 2, editor_id: 'animated_cityscape_stage1_challenge2_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge3_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge3');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawSky(); // Draw the sky at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawSky(); // Draw the sky at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawSky(); // Draw the sky at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawSky(); // Draw the sky at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawSky(); // Draw the sky at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 2
              
            }
            
            function drawSky() {
              
              // Declare r0, g0, b0, r1, g1, b1
              // Use an if statement to calculate the values assigned to r0, g0, b0, r1, g1, b1
              // Create a vertical linear gradient from the horizon to a point 300 pixels above the horizon
              // Add color stops at positions 0 and 1
              // Use the gradient to fill a rectangle positioned at (0, 0) that goes down to the horizon and across the width of the canvas
              
            }
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge3
          .alert


  #challenge4.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 4
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge4Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            To turn the sky along the horizon red as the sun sets, we need to add a
            third color stop between positions <code>0</code> and <code>1</code>. The
            third color stop will confine the red color to a narrow band.
          %p
            Start by setting <code>horizonY</code>, the y-coordinate of the horizon,
            and copying the definitions for the <code>rgbColor()</code> and <code>drawSky()</code>
            functions from Challenge 3.
          %p
            Inside the <code>drawSky()</code> function, declare the variables <code>pMiddle</code>,
            <code>rMiddle</code>, <code>gMiddle</code>, and <code>bMiddle</code> for the middle color
            stop. We are using <code>pMiddle</code> to set the position of the color stop. By starting
            at position <code>1</code> and moving down to position <code>0</code>, it will confine the
            red color to a narrower and narrower band until it disappears completely.
          %p
            If <code>time < 5</code> or <code>time > 7</code>, set <code>pMiddle</code> to -1.
          %p
            Why are we setting <code>pMiddle</code> to -1? Before 5:00 pm and after 7:00 pm, we only
            need to add color stops at positions <code>0</code> and <code>1</code>; we aren't adding
            a third color stop at position <code>pMiddle</code>. By setting <code>pMiddle</code> to -1,
            we are letting ourselves know not to add the third color stop later on.
          %p
            In the code block for the else clause, change the calculations for the color at
            position <code>0</code> and add the calculations for the color at position <code>pMiddle</code>.
            The calculations for the color at position <code>1</code> stay the same.
          %ul
            %li
              <code>r0</code>: 255
            %li
              <code>g0</code>: 255 &rarr; 0
            %li
              <code>b0</code>: 255 &rarr; 0
            %li
              <code>pMiddle</code>: 1 &rarr; 0
            %li
              <code>rMiddle</code>: 102
            %li
              <code>gMiddle</code>: 153 &rarr; 102
            %li
              <code>bMiddle</code>: 255 &rarr; 102
          %p
            This changes the color of the sky at position <code>0</code> from white to red
            and the color of the sky at position <code>1</code> from blue to dark gray. We
            use the middle color stop at position <code>pMiddle</code> to make the red band
            at the horizon narrower. The color of the sky at the middle color stop changes
            from blue to gray, but it also moves closer to the horizon as <code>pMiddle</code>
            changes from 1 to 0.
          %p
            After creating the linear gradient and adding color stops at positions <code>0</code>
            and <code>1</code>, add the middle color stop only if <code>pMiddle >= 0</code>. If
            <code>pMiddle</code> is -1, the program will skip this step and the middle color stop
            won't be added.
          %pre
            %code
              :preserve
                if (pMiddle >= 0) {
                  gradient.addColorStop(pMiddle, rgbColor(rMiddle, gMiddle, bMiddle));
                }
          %p
            The program should now draw slices of the sky as it gets darker and redder along
            the horizon at 5:00, 5:30, 6:00, 6:30, and 7:00 pm. If you need help with if statements
            and linear gradients, visit the
            = link_to_lesson('If Statements', :if_statements, nil, class: 'reference-link', data: {slug: :if_statements})
            and
            = link_to_lesson('createLinearGradient()', :create_linear_gradient, nil, class: 'reference-link', data: {slug: :create_linear_gradient})
            lessons.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :create_linear_gradient]
          = render 'lessons/code_preview', stage: 1, challenge: 3, editor_id: 'animated_cityscape_stage1_challenge3_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge4_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge4');
            var context = canvas.getContext('2d');

            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawSky(); // Draw the sky at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawSky(); // Draw the sky at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawSky(); // Draw the sky at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawSky(); // Draw the sky at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawSky(); // Draw the sky at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 3
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 3
              
              // Declare variables pMiddle, rMiddle, gMiddle, bMiddle for the middle color stop
              // Set pMiddle to -1 if time < 5 or time > 7
              // Update p0, g0, b0 to go from (255, 255, 255) to (255, 0, 0)
              // Calculate pMiddle to go from 1 to 0
              // Calculate rMiddle, gMiddle, bMiddle to go from (102, 153, 255) to (102, 102, 102)
              // Add the middle color stop if pMiddle >= 0
              
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge4
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Mouse Click
          %p
            At this point, we can draw the sky and ground at any time of day by manually
            setting the <code>time</code> variable. The next step is writing a program
            which updates the <code>time</code> variable and redraws the scene automatically.
          %p
            A JavaScript program is triggered by events. So far, we've done all of our
            drawing immediately when the page first loads. But we can also tell our program
            to listen for events and run specific functions when those events occur.
          %p
            In this example, we run the following code when the page loads:
          %pre
            %code
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
          %p
            We start by storing a reference to the canvas and the canvas's context in the
            variables <code>canvas</code> and <code>context</code>. Then, we declare the global
            variables <code>squareX</code> and <code>squareY</code>. We need to declare these
            variables globally so all of our functions can use them and the values stored in them
            are persistent and aren't deleted once a function ends. To learn more about variables
            and scope, visit the
            = link_to_lesson('Variables', :variables, nil, class: 'reference-link', data: {slug: :variables})
            lesson. Finally, we call the <code>initScene()</code> function and use the
            <code>addEventListener()</code> method to register an event listener on the canvas
            object.
          %p
            The <code>initScene()</code> function sets the initial values of <code>squareX</code>
            and <code>squareY</code> and calls the <code>drawScene()</code> function:
          %pre
            %code
              :preserve
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
          %p
            The <code>drawScene()</code> function draws a square filled with the color
            <code>'RoyalBlue'</code> at the coordinates (<code>squareX</code>, <code>squareY</code>):
          %pre
            %code
              :preserve
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
          %p
            By registering to listen for <code>'click'</code> events, the program will
            automatically call the <code>updateScene()</code> function whenever a mouse
            click is detected on the canvas. Note: Because we are passing the
            <code>updateScene()</code> function into the <code>addEventListener()</code>
            method as a variable, we don't include parentheses after the function name. To learn
            more about passing functions as variables and registering event listeners, visit the
            = link_to_lesson('Functions', :functions, nil, class: 'reference-link', data: {slug: :functions})
            and
            = link_to_lesson('Event Listeners', :event_listeners, nil, class: 'reference-link', data: {slug: :event_listeners})
            lessons.
          %p
            The <code>updateScene()</code> method adds 30 to <code>squareX</code> and 20
            to <code>squareY</code> before calling the <code>drawScene()</code> function
            and drawing another square:
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 30; // This is a shorter way of writing squareX = squareX + 30
                  squareY += 20; // This is a shorter way of writing squareY = squareY + 20
                  
                  drawScene();
                }
          %p
            Now we can automatically update the drawing on the canvas simply by clicking
            on it. Note that the new scene is drawn on top of the existing scene. If we
            wanted to redraw the square and make it look like the square is moving, we'd
            have to clear the canvas first.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example4_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 30; // This is a shorter way of writing squareX = squareX + 30
                  squareY += 20; // This is a shorter way of writing squareY = squareY + 20
                  
                  drawScene();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example4


  #challenge5.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 5
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge5Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like at 6:12 pm
          %p
            Write a program that increases the <code>time</code> and redraws the scene
            when a mouse click is detected on the canvas.
          %p
            Start by copying the definitions for the <code>drawSky()</code>,
            <code>drawGround()</code>, and <code>rgbColor()</code> functions from Challenges 2 and 4.
          %p
            Inside the <code>initScene()</code> function, set <code>time</code> to 5,
            set <code>horizonY</code> so the horizon is 100 pixels above the bottom of
            the canvas, and then call the <code>drawScene()</code> function.
          %p
            Inside the <code>drawScene()</code> function, draw the sky and ground. Then,
            call the <code>drawTime()</code> function to automatically draw the time in the
            bottom left corner of the canvas.
          %p
            Inside the <code>updateScene()</code> function, increase the <code>time</code>
            by 0.2 if <code>time < 7</code>, else reset the <code>time</code> back to 5.
            Then, call the <code>drawScene()</code> function to draw a new scene on top of
            the current one.
          %p
            Press "Run" and click on the canvas enough times to see the sky and ground change
            color between 5:00 and 7:00 pm. Once you feel satisfied that the scene is updating
            and drawing correctly, mark the challenge as complete by selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners]
          = render 'lessons/code_preview', stage: 1, challenge: 4, editor_id: 'animated_cityscape_stage1_challenge4_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge5_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge5');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY;
            
            initScene();
            canvas.addEventListener('click', updateScene);
            
            function initScene() {
              
              // Set the time to 5
              // Set horizonY so the horizon is 100 pixels above the bottom of the canvas
              // Draw the scene
              
            }
            
            function drawScene() {
              
              // Draw the sky
              // Draw the ground
              
              drawTime(); // Draw the time in the bottom left corner
              
            }
            
            function updateScene() {
              
              // If time < 7, increase the time by 0.2, else reset the time back to 5
              // Draw the scene
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawGround() {
              
              // Copy the function definition from Challenge 2
              
            }
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawTime() {
              var t;
              var h = Math.floor(time);
              var m = Math.round(60 * (time - h));
              
              if (m >= 10) {
                t = h + ':' + m;
              } else {
                t = h + ':0' + m;
              }
              
              context.save();
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.fillText(t, 10, canvas.height - 10);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge5
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Timer
          %p
            Instead of using a mouse click to update the time and redraw the scene,
            we are going to use a timer.
          %p
            In this example, we set up a timer to update the scene from the previous
            example. We start by declaring the global variable <code>timer</code>. Then,
            instead of adding an event listener to the canvas object to detect mouse
            clicks, we use the <code>setInterval()</code> method to create a timer that will
            automatically call the <code>updateScene()</code> function every 25 milliseconds.
            We store a reference to the timer in the variable <code>timer</code>.
          %pre
            %code
              :preserve
                var timer;
                
                timer = setInterval(updateScene, 25); // Call the updateScene() function every 25 milliseconds
          %p
            Again, because we are passing the <code>updateScene()</code> function into
            the <code>setInterval()</code> method as a variable, we don't include
            parentheses at the end of the function name. The number <code>25</code> tells
            the timer how long to wait before calling the <code>updateScene()</code>
            function again. The <code>setInterval()</code> method measures time in
            milliseconds and there are 1000 milliseconds in one second. So, if the timer
            calls the <code>updateScene()</code> function every 25 milliseconds, it will
            update the scene 40 times per second (1000 &divide; 25 = 40).
          %p
            Inside the <code>updateScene()</code> function, we increase <code>squareX</code>
            and <code>squareY</code> by 3 and 2, instead of 30 and 20, so the square doesn't
            move as far in each update. Then, if <code>squareX > canvas.width</code>, which
            means the latest square is positioned past the right edge of the canvas, we cancel
            the timer and stop updating the scene by passing the reference stored in the
            <code>timer</code> variable into the <code>clearInterval()</code> method.
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    clearInterval(timer); // Cancel the timer and stop updating the scene
                  }
                }
          %p
            Finally, inside the <code>drawScene()</code> function, before drawing the
            square, we draw a rectangle filled with the color <code>'Cornsilk'</code>
            covering the entire canvas. This will cover the previous scene, so now it
            looks like one square is moving instead of a new square being drawn each time.
          %pre
            %code
              :preserve
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
          %p
            Press "Run" to reload the page and start the animation.
          %p
            See what happens if you don't draw a rectangle over the previous scene or if
            you change how far the square moves or the time interval between updates. Note:
            if you try to update the scene too quickly, the program won't be able to keep
            up and the animation may stutter. To learn more setting timers, visit the
            = link_to_lesson('setInterval()', :set_interval, nil, class: 'reference-link', data: {slug: :set_interval})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :fill_rect, :fill_style, :set_interval]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example5_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example5');
                var context = canvas.getContext('2d');
                
                var timer;
                var squareX, squareY;
                
                initScene();
                timer = setInterval(updateScene, 25);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    clearInterval(timer); // Cancel the timer and stop updating the scene
                  }
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example5


  #challenge6.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 6
          %p
            Copy the program from Challenge 5.
          %p
            Then, change the program so that, instead of listening for mouse clicks to
            update the scene, a timer automatically calls the <code>updateScene()</code>
            function every 50 milliseconds.
          %p
            Inside the <code>updateScene()</code> function, increase the time by 0.05
            and, instead of resetting the time back to 5, cancel the timer and stop updating
            the scene if <code>time > 7</code>.
          %p
            Press "Run" and watch the sky and ground change color between 5:00 and 7:00 pm.
            If you need to slow the animation down to get a better look, increase the time
            interval passed into the <code>setInterval()</code> method. Once you feel satisfied
            that the scene is updating and drawing correctly, mark the challenge as complete by
            selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:variables, :functions, :set_interval]
          = render 'lessons/code_preview', stage: 1, challenge: 5, editor_id: 'animated_cityscape_stage1_challenge5_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge6_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge6');
            var context = canvas.getContext('2d');

            var time;
            var horizonY;
            
            initScene();
            canvas.addEventListener('click', updateScene);
            
            function initScene() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawScene() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function updateScene() {
              
              // Copy the function definition from Challenge 5
              
              // Increase the time by 0.05
              // If time >= 7, cancel the timer and stop updating the scene
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawGround() {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 5
              
            }
            
            function drawTime() {
              var t;
              var h = Math.floor(time);
              var m = Math.round(60 * (time - h));
              
              if (m >= 10) {
                t = h + ':' + m;
              } else {
                t = h + ':0' + m;
              }
              
              context.save();
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.fillText(t, 10, canvas.height - 10);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge6
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Play and Pause the Scene
          %p
            In this example, we add event listeners to the previous example's program
            to play and pause the scene.
          %p
            We can register our program to listen for more than mouse click events. On
            a web page, only one HTML element can have the focus at a time. The focus
            determines which element is actively receiving keyboard events. On this page
            alone there are thirteen editors. It would get kind of crazy if you were typing
            into more than one editor at a time.
          %p
            Note: A canvas element does not normally receive the focus. We have enabled
            each canvas to receive the focus by setting its <code>tabindex</code> attribute.
            That's not something you need to know about until you start creating the HTML
            for your own web pages.
          %p
            Because we have enabled each canvas to receive the focus, clicking on a
            canvas selects it and triggers a <code>'focus'</code> event. Clicking on a
            different part of the page deselects it and triggers a <code>'blur'</code>
            event. We start by adding event listeners to play the scene when the canvas
            receives a <code>'focus'</code> event and pause the scene when the canvas
            receives a <code>'blur'</code> event.
          %pre
            %code
              :preserve
                canvas.addEventListener('focus', playScene);
                canvas.addEventListener('blur', pauseScene);
          %p
            Instead of starting the timer when the page first loads, we start the timer
            inside the <code>playScene()</code> function. We also check the position of
            the last square before starting the timer. If the last square is off the canvas,
            we reset it's position.
          %pre
            %code
              :preserve
                function playScene() {
                  if (squareX > canvas.width) {
                    squareX = 10;
                    squareY = 10; // Reset the square's position
                  }
                  
                  timer = setInterval(updateScene, 25);
                }
          %p
            Inside the <code>pauseScene()</code> function, we cancel the timer and
            draw the text string <code>'Click to Play'</code> in the center of the
            canvas so the user knows how to start the animation.
          %pre
            %code
              :preserve
                function pauseScene() {
                  clearInterval(timer);
                  
                  context.save();
                  context.fillStyle = 'Black';
                  context.font = '16px Arial';
                  context.textAlign = 'center';
                  context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
                  context.restore();
                }
          %p
            We also call the <code>pauseScene()</code> function when the page first loads
            so the <code>'Click to Play'</code> text string is drawn right away.
          %p
            Then, inside the <code>updateScene()</code> function, instead of canceling
            the timer if <code>squareX > canvas.width</code>, we use the <code>blur()</code>
            method to blur the canvas. When the canvas loses the focus, it receives a
            <code>blur</code> event and the <code>pauseScene()</code> function is called.
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    canvas.blur(); // Remove the focus from the canvas
                  }
                }
          %p
            Click on the canvas to start the animation. The animation will continue
            running until you click on a different part of the page or until the latest
            square is positioned past the right edge of the canvas. If you restart the
            animation and the latest square was positioned past the right edge of the
            canvas, <code>squareX</code> and <code>squareY</code> are reset and the animation
            starts again from the beginning.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners, :fill_rect, :fill_style, :set_interval]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example6_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example6');
                var context = canvas.getContext('2d');
                
                var timer;
                var squareX, squareY;
                
                initScene();
                pauseScene();
                canvas.addEventListener('focus', playScene);
                canvas.addEventListener('blur', pauseScene);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'Cornsilk';
                  context.fillRect(0, 0, canvas.width, canvas.height); // Draw a rectangle over the entire canvas
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 3; // This is a shorter way of writing squareX = squareX + 3
                  squareY += 2; // This is a shorter way of writing squareY = squareY + 2
                  
                  drawScene();
                  
                  if (squareX > canvas.width) {
                    canvas.blur(); // Remove the focus from the canvas
                  }
                }
                
                function playScene() {
                  if (squareX > canvas.width) {
                    squareX = 10;
                    squareY = 10; // Reset the square's position
                  }
                  
                  timer = setInterval(updateScene, 25);
                }
                
                function pauseScene() {
                  clearInterval(timer);
                  
                  context.save();
                  context.fillStyle = 'Black';
                  context.font = '16px Arial';
                  context.textAlign = 'center';
                  context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
                  context.restore();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example6


  #challenge7.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 7
          %p
            Copy the program from Challenge 6.
          %p
            Then, change the program so the scene is initially paused and the time set
            to 2. Play the scene when the canvas receives the focus and continue playing
            the scene until the canvas loses the focus or until <code>time > 12</code>. If
            the canvas receives the focus and the time is already greater than 12, reset
            the time back to 2 and replay the scene from the beginning.
          %p
            Press "Run" and click on the canvas to start playing the scene. Once you feel
            satisfied that the scene is playing and pausing correctly, mark the challenge
            as complete by selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:variables, :functions, :event_listeners, :set_interval]
          = render 'lessons/code_preview', stage: 1, challenge: 6, editor_id: 'animated_cityscape_stage1_challenge6_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge7_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge7');
            var context = canvas.getContext('2d');

            // Copy the program from Challenge 6 here
            
            function playScene() {
              
            }
            
            function pauseScene() {
              
              // Cancel the timer
              
              context.save();
              context.fillStyle = 'rgba(0, 0, 0, 0.2)';
              context.fillRect(canvas.width / 2 - 55, canvas.height / 2 - 18, 110, 24);
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.textAlign = 'center';
              context.fillText('Click to Play', canvas.width / 2, canvas.height / 2);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge7
          .alert
