#animated_cityscape_stage1.page
  %h1
    Stage 1
  .description.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Overview
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/overviewVisual1.png', class: 'img-fluid')
          %p
            In the Basic Cityscape Challenge, we drew three rows of randomly-generated
            buildings, creating a 3D effect by drawing the buildings in the back smaller
            and darker.
          %p
            In the first stage of the Animated Cityscape Challenge, we draw the
            sky behind the buildings, changing the color of the sky to simulate nightfall.


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Review the Basic Cityscape Challenge
          %p
            Because we are extending the program for the Basic Cityscape Challenge to
            animate the drawing, it's important to understand how that program works.
          %p
            We start by drawing a gray rectangle (color <code>'#CCCCCC'</code>) for
            the ground beneath the buildings. Then, we use the <code>drawBuildingRow()</code>
            function to draw three rows of buildings.
          %pre
            %code
              :preserve
                context.fillStyle = '#CCCCCC';
                context.fillRect(0, 220, canvas.width, canvas.height - 220);
                
                drawBuildingRow(0, 280, 0.6);
                drawBuildingRow(0, 300, 0.8);
                drawBuildingRow(0, 320, 1.0);
          %p
            The first row of buildings is positioned at (0, 280) and drawn at 60% scale,
            the second row of buildings is positioned at (0, 300) and drawn at 80% scale, and
            the third row of buildings is positioned at (0, 320) and drawn at 100% scale.
          %p
            Inside the <code>drawBuildingRow()</code> function, we use the <code>scale</code>
            parameter to calculate the color of the buildings in the row. The smaller the scale,
            the darker the buildings. Then, we use a while loop to draw buildings the width of the
            canvas. To draw a building, we randomly generate the number of office units per floor,
            the number of floors, the type of windows, and the type of roof for the building and
            pass those values into the <code>drawBuilding()</code> function.
          %p
            The <code>randomInteger()</code> function is used to generate random integers,
            switch statements inside the <code>drawWindow()</code> and <code>drawRoof()</code>
            functions are used to draw the four different types of windows and roofs, and
            nested for loops are used to draw windows in each office unit in each building.
          %p
            Please make sure you fully understand the program in the example below before continuing on in
            this challenge. If you need help, visit the Basic Cityscape Challenge and its relevant lessons.
          = render 'lessons/relevant', relevant: [:variables, :functions, :for_loops, :switch_statements, :while_loops, :fill_rect, :fill_style, :random, :scale]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example1_editor', cols: 12} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example1');
                var context = canvas.getContext('2d');
                
                context.save();
                context.fillStyle = '#CCCCCC';
                context.fillRect(0, 220, canvas.width, canvas.height - 220);
                
                drawBuildingRow(0, 280, 0.6);
                drawBuildingRow(0, 300, 0.8);
                drawBuildingRow(0, 320, 1.0);
                
                context.restore();
                
                function drawBuildingRow(rowX, groundY, scale) {
                  context.save();
                  context.translate(rowX, groundY);
                  context.scale(scale, scale);
                  
                  var c = Math.round(153 * scale);
                  var buildingColor = 'rgb(' + c + ', ' + c + ', ' + c + ')';
                  var windowColor = 'rgb(102, 102, 102)';
                  
                  var x = 0;
                  while (x < canvas.width / scale) {
                    var units = randomInteger(4, 10);
                    var floors = randomInteger(6, 20);
                    var windowType = randomInteger(0, 3);
                    var roofType;
                    
                    if (units > 8) {
                			roofType = randomInteger(0, 1);
                		} else if (units > 6) {
                			roofType = randomInteger(0, 2);
                		} else {
                			roofType = randomInteger(0, 3);
                		}
                    
                    var w = 16 * units + 8;
                    var h = 16 * floors + 8;
                    
                    drawBuilding(x, 0, w, h, units, floors, windowType, roofType, buildingColor, windowColor);
                    x = x + w + 12;
                  }
                  
                  context.restore();
                }
                
                function drawBuilding(leftX, groundY, w, h, units, floors, windowType, roofType, buildingColor, windowColor) {
                  var x = leftX;
                  var y = groundY - h;
                  
                  context.save();
                  context.translate(x, y);
                  context.fillStyle = buildingColor;
                  context.fillRect(0, 0, w, h);
                  drawRoof(w, roofType);
                  
                  context.translate(4, 4);
                  context.fillStyle = windowColor;
                  
                  for (var i = 0; i < floors; i = i + 1) {
                    context.save();
                    
                    for (var j = 0; j < units; j = j + 1) {
                      drawWindow(windowType);
                      context.translate(16, 0);
                    }
                    
                    context.restore();
                    context.translate(0, 16);
                  }
                  
                  context.restore();
                }
    
                function drawWindow(windowType) {
                  context.save();
                  
                  switch (windowType) {
                		case 0:
                			context.fillRect(4, 2, 8, 10);
                			break;
                		
                		case 1:
                			context.fillRect(2, 3, 5, 8);
                			context.fillRect(9, 3, 5, 8);
                			break;
                		
                		case 2:
                			context.fillRect(0, 3, 16, 8);
                			break;
                		
                		case 3:
                			context.fillRect(5, 1, 6, 14);
                			break;
                	}
                  
                  context.restore();
                }
                
                function drawRoof(w, roofType) {
                  context.save();
                  
                  switch(roofType) {
                		case 0:
                			// draw nothing
                			break;
                		
                		case 1:
                			context.fillRect(8, -16, w - 16, 16);
                			break;
                		
                		case 2:
                			context.fillRect(8, -24, w - 16, 24);
                			context.fillRect((w - 32) / 2, -48, 32, 24);
                			context.fillRect((w - 8) / 2, -80, 8, 56);
                			break;
                		
                		case 3:
                			context.beginPath();
                			context.moveTo(w / 2, -80);
                			context.lineTo(w / 2 + 16, -16);
                			context.lineTo(w / 2 - 16, -16);
                			context.closePath();
                			context.fill();
                			context.fillRect((w - 64) / 2, -16, 64, 16);
                			break;
                	}
                  
                  context.restore();
                }
                
                function randomInteger(min, max) {
                  return (min + Math.floor((max - min + 1) * Math.random()));
                }

            .visual.col-xs-12.pt-2
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example1


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Draw the Sky Behind the Buildings
          %p
            The sky behind the buildings is not a solid color. During the day, the sky is
            white along the horizon and bluer higher up. At night, the sky is gray along the
            horizon and darker higher up. And as the sun sets, the sky along the horizon
            turns red.
          %p
            To draw the sky, we use a linear gradient. A linear gradient smoothly transitions
            from one color to another, such as white to blue or gray to dark gray. In
            this example, we create a linear gradient using the <code>createLinearGradient()</code>
            method and assign it to a variable named <code>gradient</code>:
          %pre
            %code
              :preserve
                var gradient = context.createLinearGradient(40, 0, 360, 0);
          %p
            We create a linear gradient by passing the <code>createLinearGradient()</code> method
            the coordinates for the gradient's start position and end position. Because the two points,
            (40, 0) and (360, 0), form a horizontal line, the linear gradient is horizontal. It starts
            at x = 40 and ends at x = 360. The y-coordinates of the two points in a horizontal linear
            gradient don't make a difference as long as they are the same.
          %p
            The next step is setting the colors in the gradient:
          %pre
            %code
              :preserve
                gradient.addColorStop(0, 'Red');
                gradient.addColorStop(0.6, 'Blue');
                gradient.addColorStop(1, 'Black');
          %p
            This sets the color in the gradient at x = 40 (position <code>0</code>) to <code>'Red'</code>
            and the color at x = 360 (position <code>1</code>) to <code>'Black'</code>. We also set
            the color at x = 232 (position <code>0.6</code>) to <code>'Blue'</code>. This position is 60%
            of the way from position <code>0</code> to position <code>1</code>.
          %p
            Finally, we assign the linear gradient stored in the variable <code>gradient</code> to the
            <code>context.fillStyle</code> property and use the <code>context.fillRect()</code> method to
            draw a filled rectangle.
          %pre
            %code
              :preserve
                context.fillStyle = gradient;
                context.fillRect(40, 40, 320, 240);
          %p
            Between position <code>0</code> and position <code>0.6</code>, the color filling the rectangle
            changes from <code>'Red'</code> to <code>'Blue'</code>. Between position <code>0.6</code>
            and position <code>1</code>, the color changes from <code>'Blue'</code> to <code>'Black'</code>.
          %p
            Change the colors in the gradient, change the position of the middle color stop, or add another
            color stop with a position between <code>0</code> and <code>1</code> to see what happens. To learn more
            about linear gradients, visit the
            = link_to_lesson('createLinearGradient()', :create_linear_gradient, nil, class: 'reference-link', data: {slug: :create_linear_gradient})
            lesson.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :fill_rect, :fill_style, :create_linear_gradient]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example2_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example2');
                var context = canvas.getContext('2d');
                
                var gradient = context.createLinearGradient(40, 0, 360, 0);

                gradient.addColorStop(0, 'Red');
                gradient.addColorStop(0.6, 'Blue');
                gradient.addColorStop(1, 'Black');

                context.fillStyle = gradient;
                context.fillRect(40, 40, 320, 240);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example2


  #challenge1.challenge.row.py-3
    .col-xs-12
      .row.pb-2
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 1
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge1Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Declare a variable named <code>horizonY</code> and assign it the value
            <code>canvas.height - 100</code>. This sets the y-coordinate of the horizon
            100 pixels above the bottom of the canvas.
          %p
            Define a function named <code>drawSky()</code>. Inside the function, create
            a vertical linear gradient so position <code>0</code> is at the horizon and
            position <code>1</code> is 300 pixels above the horizon. Note that the y-coordinate
            of position <code>1</code> may be negative and not visible on the canvas.
          %p
            Set the color in the gradient at position <code>0</code> to <code>'rgb(255, 85, 85)'</code>,
            the color at position <code>0.3</code> to <code>'rgb(102, 119, 153)'</code>, and the color at
            position <code>1</code> to <code>'rgb(68, 85, 119)'</code>.
          %p
            Fill a rectangle with the gradient positioned at (0, 0) going down to the horizon and
            across the width of the canvas.
          %p
            Since the <code>drawSky()</code> function is setting the <code>context.fillStyle</code>
            property, make sure to save and restore the drawing state at the start and end of the function.
          %p
            Then, use the <code>drawSky()</code> function to draw the sky. This is approximately how the
            sky will look at 6:20 pm once the cityscape is animated.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :fill_rect, :fill_style, :save, :create_linear_gradient]

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge1_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge1');
            var context = canvas.getContext('2d');
            
            // DECLARE AND INITIALIZE THE horizonY VARIABLE HERE
            
            // CALL THE drawSky() FUNCTION HERE TO DRAW THE SKY
            
            // DEFINE THE drawSky() FUNCTION HERE
            // INSIDE THE drawSky() FUNCTION, CREATE A VERTICAL LINEAR GRADIENT
            // FROM THE HORIZON TO A POINT 300 PIXELS ABOVE THE HORIZON.
            // SET THE COLORS IN THE GRADIENT.
            // USE THE GRADIENT TO FILL A RECTANGLE POSITIONED AT (0, 0) THAT GOES
            // DOWN TO THE HORIZON AND ACROSS THE WIDTH OF THE CANVAS.
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge1
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Change Ground and Sky Colors Over Time
          %p
            The colors used to draw the sky in Challenge 1 are the colors of the sky at
            6:20 pm in the animated cityscape. However, the colors of the sky are slightly
            different at 6:10 pm and 6:30 pm. Because we change the color of the ground and
            sky forty times between 5:00 pm and 7:00 pm, we need an easy way to calculate
            these colors automatically.
          %p
            In this example, we use two for loops to draw two rows of rectangles. The first
            for loop uses the variable <code>i</code> as its counter. Inside the for loop,
            we use an if statement to calculate the height of the rectangle depending on the
            value of the counter. Note how the height of the rectangle starts at 40, climbs
            steadily to 100, and then levels out again. We want the ground and sky colors to
            change in the same way as the sun sets.
          %pre
            %code
              :preserve
                if (i < 6) {
                  h = 40;
                } else if (i > 15) {
                  h = 100;
                } else {
                  h = 40 + 60 * (i - 6) / 9;
                }
          %p
            When the program reaches the if statement, it checks the first condition. If
            <code>i < 6</code>, the height of the rectangle is set to 40. If the first condition
            is false, then the program checks the second condition. If <code>i > 15</code>, the
            height of the rectangle is set to 100. If both conditions are false, then the program
            runs the code block in the else clause and the height of the rectangle is set to the
            value of <code>40 + 60 * (i - 6) / 9</code>.
          %p
            The expression <code>40 + 60 * (i - 6) / 9</code> is designed to increase from 40 to
            100 as <code>i</code> increases from 6 to 15. Note that <code>(6 - 6) / 9</code> = 0
            when <code>i</code> is 6 and <code>(15 - 6) / 9</code> = 1 when <code>i</code> is 15.
          %p
            In the second for loop, we design the expression inside the if statement so the height
            of the rectangle decreases from 160 to 50 as <code>j</code> increases from 3 to 10. Can
            you update the second for loop so the height of the rectangle decreases from 150 to 90
            as <code>j</code> increases from 8 to 13?
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :if_statements, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example3_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example3');
                var context = canvas.getContext('2d');
                
                var x, y, h;
                context.fillStyle = 'Crimson';
                
                for (var i = 0; i < 20; i = i + 1) {
                  if (i < 6) {
                    h = 40;
                  } else if (i > 15) {
                    h = 100;
                  } else {
                    h = 40 + 60 * (i - 6) / 9;
                  }
                  
                  x = 20 * i;
                  y = 120 - h;
                  
                  context.fillRect(x, y, 18, h);
                }
                
                context.fillStyle = 'BlueViolet';
                
                for (var j = 0; j < 20; j = j + 1) {
                  if (j < 3) {
                    h = 160;
                  } else if (j > 10) {
                    h = 50;
                  } else {
                    h = 160 - 110 * (j - 3) / 7;
                  }
                  
                  x = 20 * j;
                  y = 300 - h;
                  
                  context.fillRect(x, y, 18, h);
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example3


  #challenge2.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 2
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge2Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            The <code>drawGround()</code> function will draw the rectangle for the
            ground using darker shades of gray as the time increases from 5:00 pm to
            7:00 pm. Because we are calculating RGB values based on the time, we
            start by defining the <code>rgbColor()</code> function to make it easy to
            combine RGB values into a text string in 'rgb()' notation.
          %p
            The <code>rgbColor()</code> function has three parameters: <code>r</code>,
            <code>g</code>, and <code>b</code>. Round the values stored in the three parameters
            using the <code>Math.round()</code> function and combine them into a text
            string in 'rgb()' notation using the <code>+</code> operator. Then, return the text
            string from the function using a return statement.
          %p
            If you need help, examine the <code>drawBuildingRow()</code> and <code>randomInteger()</code>
            functions in the Basic Cityscape Challenge program at the top of the page to see how we
            combined values into a text string to describe a row's building color and how we returned randomly
            generated integers from a function, or visit the
            = link_to_lesson('fillStyle', :fillStyle, nil, class: 'reference-link', data: {slug: :fillStyle})
            and
            = link_to_lesson('Functions', :functions, nil, class: 'reference-link', data: {slug: :functions})
            lessons.
          %p
            Inside the <code>drawGround()</code> function, declare the variable <code>c</code>. We
            can use this one variable to store the red, green, and blue values of the ground's color
            because all three values are the same. If <code>time < 5</code>, set <code>c = 204</code>.
            If <code>time > 7</code>, set <code>c = 102</code>. If <code>time</code> is between 5 and 7,
            create an expression so <code>c</code> decreases from 204 to 102 as <code>time</code> increases
            from 5 to 7. Pass the value of <code>c</code> into the <code>rgbColor()</code> function and
            assign the color returned from the function to the <code>context.fillStyle</code> property.
            Remember, <code>c</code> is the value of the red, green, and blue values of the color.
          %p
            Then, use the <code>context.fillRect()</code> method to draw a rectangle from (0, <code>horizonY</code>)
            to the bottom of the canvas and the width of the canvas. Make sure to save and restore the drawing
            state since the <code>drawGround()</code> function is setting the <code>context.fillStyle</code> property.
          %p
            Finally, set the value of <code>horizonY</code> so the y-coordinate of the horizon is 100 pixels
            above the bottom of the canvas. The program should now draw slices of the ground as it gets darker
            at 5:00, 5:30, 6:00, 6:30, and 7:00 pm.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :round]
          = render 'lessons/code_preview', stage: 1, challenge: 1, editor_id: 'animated_cityscape_stage1_challenge1_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge2_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge2');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawGround(); // Draw the ground at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawGround(); // Draw the ground at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawGround(); // Draw the ground at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawGround(); // Draw the ground at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawGround(); // Draw the ground at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Create and return a text string in rgb() notation after rounding the values stored in r, g, and b
              
            }
            
            function drawGround() {
              
              // Declare the variable c
              // Use an if statement to calculate the value of c
              // Use the rgbColor() function to get the color of the ground and assign it to the fillStyle
              // Draw a filled rectangle from (0, horizonY) to the bottom of the canvas and the width of the canvas
              
            }
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge2
          .alert


  #challenge3.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 3
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge3Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            Now we are going to update the <code>drawSky()</code> function so the
            gradient used to fill the sky also changes depending on the time of day.
            First, we will make the sky change from blue to dark gray. We will add
            the red horizon later.
          %p
            Inside the <code>drawSky()</code> function, start by declaring six
            variables. To keep the function compact, we can declare multiple variables
            on each line. Just separate the variables with commas and make sure to end
            each line with a semicolon.
          %pre
            %code
              :preserve
                var r0, g0, b0;
                var r1, g1, b1;
          %p
            The variables <code>r0</code>, <code>g0</code>, and <code>b0</code> are the
            RGB values of the color at position <code>0</code> in the gradient. The variables
            <code>r1</code>, <code>g1</code>, and <code>b1</code> are the RGB values of the
            color at position <code>1</code>.
          %p
            If <code>time < 5</code>, set <code>r0</code>, <code>g0</code>, and <code>b0</code>
            to 255; and set <code>r1</code> to 102, <code>g1</code> to 153, and <code>b1</code>
            to 255. And just as we can declare multiple variables on one line, we can also assign
            multiple variables on one line.
          %pre
            %code
              :preserve
                r0 = 255, g0 = 255, b0 = 255; // The sky is white at position 0
                r1 = 102, g1 = 153, b1 = 255; // The sky is blue at position 1
          %p
            If <code>time > 7</code>, set <code>r0</code>, <code>g0</code>, and <code>b0</code> to 102;
            and set <code>r1</code>, <code>g1</code>, and <code>b1</code> to 51.
          %pre
            %code
              :preserve
                r0 = 102, g0 = 102, b0 = 102; // The sky is gray at position 0
                r1 = 51, g1 = 51, b1 = 51; // The sky is dark gray at position 1
          %p
            Finally, if <code>time < 5</code> and <code>time > 7</code> are both false, create
            expressions to calculate the RGB values of the colors at both positions as <code>time</code>
            increases from 5 to 7. This changes the color of the sky at position <code>0</code> from white
            to gray and the color of the sky at position <code>1</code> from blue to dark gray.
          %ul
            %li
              <code>r0</code>: 255 &rarr; 102
            %li
              <code>g0</code>: 255 &rarr; 102
            %li
              <code>b0</code>: 255 &rarr; 102
            %li
              <code>r1</code>: 102 &rarr; 51
            %li
              <code>g1</code>: 153 &rarr; 51
            %li
              <code>b1</code>: 255 &rarr; 51
          %p
            Now, just as in Challenge 1, create a vertical linear gradient so position
            <code>0</code> is at the horizon and position <code>1</code> is 300 pixels above the horizon.
          %p
            Instead of hardcoding three color stops, add color stops at positions <code>0</code>
            and <code>1</code> and use the RGB values stored in the six variables to set the colors
            using the <code>rgbColor()</code> function.
          %p
            Fill a rectangle with the gradient positioned at (0, 0) going down to the horizon and
            across the width of the canvas.
          %p
            Then, set the value of <code>horizonY</code> so the y-coordinate of the horizon is 100 pixels
            above the bottom of the canvas. The program should now draw slices of the sky as it gets darker
            at 5:00, 5:30, 6:00, 6:30, and 7:00 pm.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :create_linear_gradient]
          = render 'lessons/code_preview', stage: 1, challenge: 2, editor_id: 'animated_cityscape_stage1_challenge2_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge3_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge3');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawSky(); // Draw the sky at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawSky(); // Draw the sky at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawSky(); // Draw the sky at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawSky(); // Draw the sky at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawSky(); // Draw the sky at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 2
              
            }
            
            function drawSky() {
              
              // Declare r0, g0, b0, r1, g1, b1
              // Use an if statement to calculate the values assigned to r0, g0, b0, r1, g1, b1
              // Create a vertical linear gradient from the horizon to a point 300 pixels above the horizon
              // Add color stops at positions 0 and 1
              // Use the gradient to fill a rectangle positioned at (0, 0) that goes down to the horizon and across the width of the canvas
              
            }
            
        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge3
          .alert


  #challenge4.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 4
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge4Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like
          %p
            To turn the sky along the horizon red as the sun sets, we need to add a
            third color stop between positions <code>0</code> and <code>1</code>. The
            third color stop will confine the red color to a narrow band.
          %p
            Start by setting <code>horizonY</code>, the y-coordinate of the horizon,
            and copying the definitions for the <code>rgbColor()</code> and <code>drawSky()</code>
            functions from Challenge 3.
          %p
            Inside the <code>drawSky()</code> function, declare the variables <code>pMiddle</code>,
            <code>rMiddle</code>, <code>gMiddle</code>, and <code>bMiddle</code> for the middle color
            stop. We are using <code>pMiddle</code> to set the position of the color stop. By starting
            at position <code>1</code> and moving down to position <code>0</code>, it will confine the
            red color to a narrower and narrower band until it disappears completely.
          %p
            If <code>time < 5</code> or <code>time > 7</code>, set <code>pMiddle</code> to -1.
          %p
            Why are we setting <code>pMiddle</code> to -1? Before 5:00 pm and after 7:00 pm, we only
            need to add color stops at positions <code>0</code> and <code>1</code>; we aren't adding
            a third color stop at position <code>pMiddle</code>. By setting <code>pMiddle</code> to -1,
            we are letting ourselves know not to add the third color stop later on.
          %p
            In the code block for the else clause, change the calculations for the color at
            position <code>0</code> and add the calculations for the color at position <code>pMiddle</code>.
            The calculations for the color at position <code>1</code> stay the same.
          %ul
            %li
              <code>r0</code>: 255
            %li
              <code>g0</code>: 255 &rarr; 0
            %li
              <code>b0</code>: 255 &rarr; 0
            %li
              <code>pMiddle</code>: 1 &rarr; 0
            %li
              <code>rMiddle</code>: 102
            %li
              <code>gMiddle</code>: 153 &rarr; 102
            %li
              <code>bMiddle</code>: 255 &rarr; 102
          %p
            This changes the color of the sky at position <code>0</code> from white to red
            and the color of the sky at position <code>1</code> from blue to dark gray. We
            use the middle color stop at position <code>pMiddle</code> to make the red band
            at the horizon narrower. The color of the sky at the middle color stop changes
            from blue to gray, but it also moves closer to the horizon as <code>pMiddle</code>
            changes from 1 to 0.
          %p
            After creating the linear gradient and adding color stops at positions <code>0</code>
            and <code>1</code>, add the middle color stop only if <code>pMiddle >= 0</code>. If
            <code>pMiddle</code> is -1, the program will skip this step and the middle color stop
            won't be added.
          %pre
            %code
              :preserve
                if (pMiddle >= 0) {
                  gradient.addColorStop(pMiddle, rgbColor(rMiddle, gMiddle, bMiddle));
                }
          %p
            The program should now draw slices of the sky as it gets darker and redder along
            the horizon at 5:00, 5:30, 6:00, 6:30, and 7:00 pm. If you need help with if statements
            and linear gradients, visit the
            = link_to_lesson('If Statements', :if_statements, nil, class: 'reference-link', data: {slug: :if_statements})
            and
            = link_to_lesson('createLinearGradient()', :create_linear_gradient, nil, class: 'reference-link', data: {slug: :create_linear_gradient})
            lessons.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :if_statements, :fill_rect, :fill_style, :save, :translate, :create_linear_gradient]
          = render 'lessons/code_preview', stage: 1, challenge: 3, editor_id: 'animated_cityscape_stage1_challenge3_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge4_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge4');
            var context = canvas.getContext('2d');

            var time;
            var horizonY; // Set the y-coordinate of the horizon so it is 100 pixels above the bottom of the canvas
            
            context.save();
            
            time = 5.0;
            drawSky(); // Draw the sky at 5:00 pm
            context.translate(72, 0);
            time = 5.5;
            drawSky(); // Draw the sky at 5:30 pm
            context.translate(72, 0);
            time = 6.0;
            drawSky(); // Draw the sky at 6:00 pm
            context.translate(72, 0);
            time = 6.5;
            drawSky(); // Draw the sky at 6:30 pm
            context.translate(72, 0);
            time = 7.0;
            drawSky(); // Draw the sky at 7:00 pm
            
            context.restore();
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 3
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 3
              
              // Declare variables pMiddle, rMiddle, gMiddle, bMiddle for the middle color stop
              // Set pMiddle to -1 if time < 5 or time > 7
              // Update p0, g0, b0 to go from (255, 255, 255) to (255, 0, 0)
              // Calculate pMiddle to go from 1 to 0
              // Calculate rMiddle, gMiddle, bMiddle to go from (102, 153, 255) to (102, 102, 102)
              // Add the middle color stop if pMiddle >= 0
              
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge4
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Mouse Click
          %p
            At this point, we can draw the sky and ground at any time of day by manually
            setting the <code>time</code> variable. The next step is writing a program
            which updates the <code>time</code> variable and redraws the scene automatically.
          %p
            A JavaScript program is triggered by events. So far, we've done all of our
            drawing immediately when the page first loads. But we can also tell our program
            to listen for events and run specific functions when those events occur.
          %p
            In this example, we run the following code when the page loads:
          %pre
            %code
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
          %p
            We start by storing a reference to the canvas and the canvas's context in the
            variables <code>canvas</code> and <code>context</code>. Then, we declare the global
            variables <code>squareX</code> and <code>squareY</code>. We need to declare these
            variables globally so all of our functions can use them and the values stored in them
            are persistent and aren't deleted once a function ends. To learn more about variables
            and scope, visit the
            = link_to_lesson('Variables', :variables, nil, class: 'reference-link', data: {slug: :variables})
            lesson. Finally, we call the <code>initScene()</code> function and use the
            <code>addEventListener()</code> method to register an event listener on the canvas
            object.
          %p
            The <code>initScene()</code> function sets the initial values of <code>squareX</code>
            and <code>squareY</code> and calls the <code>drawScene()</code> function:
          %pre
            %code
              :preserve
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
          %p
            The <code>drawScene()</code> function draws a square filled with the color
            <code>'RoyalBlue'</code> at the coordinates (<code>squareX</code>, <code>squareY</code>):
          %pre
            %code
              :preserve
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
          %p
            By registering to listen for <code>'click'</code> events, the program will
            automatically call the <code>updateScene()</code> function whenever a mouse
            click is detected on the canvas. Note: Because we are passing the
            <code>updateScene()</code> function into the <code>addEventListener()</code>
            method as a variable, we don't include parentheses after the function name. To learn
            more about passing functions as variables and registering event listeners, visit the
            = link_to_lesson('Functions', :functions, nil, class: 'reference-link', data: {slug: :functions})
            and
            = link_to_lesson('Event Listeners', :event_listeners, nil, class: 'reference-link', data: {slug: :event_listeners})
            lessons.
          %p
            The <code>updateScene()</code> method adds 30 to <code>squareX</code> and 20
            to <code>squareY</code> before calling the <code>drawScene()</code> function
            and drawing another square:
          %pre
            %code
              :preserve
                function updateScene() {
                  squareX += 30;
                  squareY += 20;
                  
                  drawScene();
                }
          %p
            Now we can automatically update the drawing on the canvas simply by clicking
            on it. Note that the new scene is drawn on top of the existing scene. If we
            wanted to redraw the square and make it look like the square is moving, we'd
            have to clear the canvas first.
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners, :fill_rect, :fill_style]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example4_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example4');
                var context = canvas.getContext('2d');
                
                var squareX, squareY;
                
                initScene();
                canvas.addEventListener('click', updateScene);
                
                function initScene() {
                  squareX = 10;
                  squareY = 10;
                  
                  drawScene();
                }
                
                function drawScene() {
                  context.save();
                  context.fillStyle = 'RoyalBlue';
                  context.fillRect(squareX, squareY, 20, 20);
                  context.restore();
                }
                
                function updateScene() {
                  squareX += 30;
                  squareY += 20;
                  
                  drawScene();
                }

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example4


  #challenge5.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 5
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge5Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like at 6:12 pm
          %p
            Write a program that increases the <code>time</code> and redraws the scene
            when a mouse click is detected on the canvas.
          %p
            Start by copying the definitions for the <code>drawSky()</code>,
            <code>drawGround()</code>, and <code>rgbColor()</code> functions from Challenges 2 and 4.
          %p
            Inside the <code>initScene()</code> function, set <code>time</code> to 5,
            set <code>horizonY</code> so the horizon is 100 pixels above the bottom of
            the canvas, and then call the <code>drawScene()</code> function.
          %p
            Inside the <code>drawScene()</code> function, draw the sky and ground. Then,
            call the <code>drawTime()</code> function to automatically draw the time in the
            bottom left corner of the canvas.
          %p
            Inside the <code>updateScene()</code> function, increase the <code>time</code>
            by 0.2 if <code>time < 7</code>, else reset the <code>time</code> back to 5.
            Then, call the <code>drawScene()</code> function to draw a new scene on top of
            the current one.
          %p
            Press "Run" enough times to see the sky and ground change color between 5:00
            and 7:00 pm. Once you feel satisfied that the scene is updating and drawing correctly,
            mark the challenge as complete by selecting "Yes, it looks good".
          = render 'lessons/relevant', relevant: [:coordinates, :variables, :functions, :event_listeners]
          = render 'lessons/code_preview', stage: 1, challenge: 4, editor_id: 'animated_cityscape_stage1_challenge4_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge5_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge5');
            var context = canvas.getContext('2d');
            
            var time;
            var horizonY;
            
            initScene();
            canvas.addEventListener('click', updateScene);
            
            function initScene() {
              
              // Set the time to 5
              // Set horizonY so the horizon is 100 pixels above the bottom of the canvas
              // Draw the scene
              
            }
            
            function drawScene() {
              
              // Draw the sky
              // Draw the ground
              
              drawTime(); // Draw the time in the bottom left corner
              
            }
            
            function updateScene() {
              
              // If time < 7, increase the time by 0.2, else reset the time back to 5
              // Draw the scene
              
            }
            
            function drawSky() {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawGround() {
              
              // Copy the function definition from Challenge 2
              
            }
            
            function rgbColor(r, g, b) {
              
              // Copy the function definition from Challenge 4
              
            }
            
            function drawTime() {
              var t;
              var h = Math.floor(time);
              var m = Math.round(60 * (time - h));
              
              if (m >= 10) {
                t = h + ':' + m;
              } else {
                t = h + ':0' + m;
              }
              
              context.save();
              context.fillStyle = 'White';
              context.font = '16px Arial';
              context.fillText(t, 10, canvas.height - 10);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            %canvas#animated_cityscape_stage1_challenge5
          .alert


  .example.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.py-2
            Update the Time and Redraw the Scene with a Timer
          %p
            Now we are going to clean up the
            %code
              drawBuilding()
            function a little bit.
          %p
            A well-written function is like a polite robot who comes over to your house
            to do a job, and then leaves everything exactly as it found it. But if you
            look at the function used to draw a French flag in the previous example, it
            wasn't so tidy. It changed the
            %code
              context.fillStyle
            property to the color
            %code
              '#EF4135'
            and never changed it back.
          %p
            To make our function more tidy, we call
            %code
              context.save()
            at the start of the function and
            %code
              context.restore()
            at the end. Calling
            %code
              context.save()
            saves the drawing state of the context (including the current
            %code
              context.fillStyle
            property) and
            %code
              context.restore()
            restores the drawing state to the last time we saved it.
          %p
            The other change is to use the
            %code
              context.translate()
            method. Notice how we had to do calculations with x and y to figure out the positions
            of the white and red rectangles in the French flag? Imagine we had to do the same for
            dozens of windows in a building. We can eliminate a lot of that math by using the
            %code
              context.translate()
            method.
          %p
            The
            %code
              context.translate()
            method moves the origin of the coordinate system. If we move the origin to the
            top left corner of the flag, then we can draw the rectangles in the flag as though
            the flag is positioned at (0, 0). The math is much easier. However, when using the
            %code
              context.translate()
            method, it is even more important to save and then restore the drawing state. If
            changing the
            %code
              context.fillStyle
            property is rude, moving the origin of the coordinate system and not moving it back is much ruder!
          %p
            Try to predict what would happen if we left out the
            %code
              context.save()
            and
            %code
              context.restore()
            method calls in the function. To learn more about saving and restoring the
            drawing state and translating the origin of the coordinate system, visit the
            = link_to_lesson('save() / restore()', :save, nil, class: 'reference-link', data: {slug: :save})
            and
            = link_to_lesson('translate()', :translate, nil, class: 'reference-link', data: {slug: :translate})
            lessons.
          = render 'lessons/relevant', relevant: [:coordinates, :functions, :fill_rect, :save, :translate]

        .col-xs-12
          .interactive.row.py-1
            = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_example5_editor'} do
              :preserve
                var canvas = document.getElementById('animated_cityscape_stage1_example5');
                var context = canvas.getContext('2d');

                function drawFrenchFlag(x, y) {
                  context.save(); // Save the drawing state before making any changes
                  context.translate(x, y); // Move the origin of the coordinate system to the top left corner of the flag

                  context.fillStyle = '#0055A4';
                  context.fillRect(0, 0, 20, 40); // The blue rectangle is drawn at (0, 0)

                  context.fillStyle = '#FFFFFF';
                  context.fillRect(20, 0, 20, 40); // The white rectangle is drawn at (20, 0)

                  context.fillStyle = '#EF4135';
                  context.fillRect(40, 0, 20, 40); // The red rectangle is drawn at (40, 0)

                  context.restore(); // Restore the drawing state to the way it was when we saved it
                }

                drawFrenchFlag(30, 100);
                drawFrenchFlag(150, 50);
                drawFrenchFlag(300, 180);

            .visual.col-xs-6
              %h5
                Canvas
                %small (your drawing will display here)
              .canvas
                %canvas#animated_cityscape_stage1_example5


  #challenge6.challenge.row.py-3
    .col-xs-12
      .row
        .col-xs-12
          %h2.challenge-title.py-2
            Challenge 6
          %figure.float-xs-right.px-2
            = image_tag('lessons/animated_cityscape/stage1/challenge6Visual1.png', class: 'img-fluid canvas-example')
            %figcaption.text-xs-center.small What your drawing should look like

          %p
            Tidy up the drawBuilding() function from Challenge 5 in the same way by
            calling the
            %code
              context.save()
            and
            %code
              context.restore()
            methods at the start and end of the function, respectively. Then, use the
            %code
              context.translate()
            method to move the origin to (x, y) and draw the rectangle at (0, 0).
          %p
            Once the
            %code
              drawBuilding()
            function is tidy, draw one building with 10 office units per floor and 16
            floors sitting on the ground at (20, 290) and another building with 12 office
            units per floor and 10 floors sitting on the ground at (200, 290).
          %p
            The
            %code
              drawGround()
            function is used to draw the ground at y = 290. Draw the buildings before
            the ground is drawn.
          %p
            If you need help saving and restoring the drawing state and translating the origin
            of the coordinate system, visit the
            = link_to_lesson('save() / restore()', :save, nil, class: 'reference-link', data: {slug: :save})
            and
            = link_to_lesson('translate()', :translate, nil, class: 'reference-link', data: {slug: :translate})
            lessons.
          = render 'lessons/relevant', relevant: [:coordinates, :functions, :fill_rect, :save, :translate]
          = render 'lessons/code_preview', stage: 1, challenge: 5, editor_id: 'animated_cityscape_stage1_challenge5_editor'

      .row.py-1
        = render :layout => '/lessons/editor', :locals => {:editor_id => 'animated_cityscape_stage1_challenge6_editor'} do
          :preserve
            var canvas = document.getElementById('animated_cityscape_stage1_challenge6');
            var context = canvas.getContext('2d');

            function drawBuilding(leftX, groundY, units, floors) {
              var w = 0; // Calculate the width of the building
              var h = 0; // Calculate the height of the building
              var x = 0; // Calculate the x-coordinate of the building's top left corner
              var y = 0; // Calculate the y-coordinate of the building's top left corner
              
              // SAVE THE DRAWING STATE HERE
              // MOVE THE ORIGIN TO THE TOP LEFT CORNER OF THE BUILDING HERE
              // SET THE COLOR OF THE BUILDING TO #999999 HERE
              // DRAW THE BUILDING AT (0, 0) HERE USING THE VARIABLES w, h
              // RESTORE THE LAST SAVED DRAWING STATE HERE
            }
            
            // DRAW ONE BUILDING WITH 10 UNITS AND 16 FLOORS SITTING AT (20, 290) HERE
            // DRAW A SECOND BUILDING WITH 12 UNITS AND 10 FLOORS SITTING AT (200, 290) HERE
            
            drawGround(290); // Draws the ground at y = 290
            
            function drawGround(y) {
              context.save();
              context.fillStyle = 'Black';
              context.fillRect(0, y, canvas.width, 2);
              context.restore();
            }

        .visual.col-xs-6
          %h5
            Canvas
            %small (your drawing will display here)
          .canvas
            .background.hidden-xl-down= image_tag('lessons/animated_cityscape/stage1/challenge6.png')
            %canvas#animated_cityscape_stage1_challenge6
          .alert
